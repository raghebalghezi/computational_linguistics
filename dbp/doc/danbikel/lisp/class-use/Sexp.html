<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_02) on Tue Sep 27 13:34:32 EDT 2005 -->
<TITLE>
Uses of Class danbikel.lisp.Sexp (Dan Bikel's Parsing Engine)
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Uses of Class danbikel.lisp.Sexp (Dan Bikel's Parsing Engine)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp"><FONT CLASS="NavBarFont1"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Use</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sexp.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H2>
<B>Uses of Class<br>danbikel.lisp.Sexp</B></H2>
</CENTER>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Packages that use <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.lisp"><B>danbikel.lisp</B></A></TD>
<TD>Provides classes to create, read and manipulate symbolic expressions
(S-expressions), including interned symbols.&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser"><B>danbikel.parser</B></A></TD>
<TD>
Provides the core framework of this extensible statistical parsing engine.
&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.arabic"><B>danbikel.parser.arabic</B></A></TD>
<TD>Provides language-specific classes necessary to parse Arabic.&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.chinese"><B>danbikel.parser.chinese</B></A></TD>
<TD>Provides language-specific classes necessary to parse Chinese.&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.constraints"><B>danbikel.parser.constraints</B></A></TD>
<TD>
Provides interfaces and classes to allow constrain-parsing.
&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.english"><B>danbikel.parser.english</B></A></TD>
<TD>Provides language-specific classes necessary to parse English.&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.lang"><B>danbikel.parser.lang</B></A></TD>
<TD>
Provides default abstract base classes for the required interfaces of a
language package.
&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="#danbikel.parser.util"><B>danbikel.parser.util</B></A></TD>
<TD>Utility classes for displaying and manipulating parse trees.&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.lisp"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/lisp/package-summary.html">danbikel.lisp</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Subclasses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/lisp/package-summary.html">danbikel.lisp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/lisp/IntSymbol.html" title="class in danbikel.lisp">IntSymbol</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>IntSymbol</code> objects associate integers with unique references.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores a list of <code>Sexp</code> objects, which are either symbols
 or themselves lists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/lisp/SexpList.HashCache.html" title="class in danbikel.lisp">SexpList.HashCache</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A subclass of <code>SexpList</code> where a precomputed, cached
 hash value is stored with every instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/lisp/StringSymbol.html" title="class in danbikel.lisp">StringSymbol</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>StringSymbol</code> objects associate strings with unique references.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Symbol</code> objects associate strings or integers with
 unique references.  </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/lisp/package-summary.html">danbikel.lisp</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Sexp.</B><B><A HREF="../../../danbikel/lisp/Sexp.html#deepCopy()">deepCopy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a deep copy of this S-expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Sexp.</B><B><A HREF="../../../danbikel/lisp/Sexp.html#getCanonical(java.util.Map)">getCanonical</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html" title="class or interface in java.util">Map</A>&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a canonical version of this S-expression.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Sexp.</B><B><A HREF="../../../danbikel/lisp/Sexp.html#read(danbikel.lisp.SexpTokenizer)">read</A></B>(<A HREF="../../../danbikel/lisp/SexpTokenizer.html" title="class in danbikel.lisp">SexpTokenizer</A>&nbsp;tok)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the S-expression contained in the stream held by <code>tok</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Sexp.</B><B><A HREF="../../../danbikel/lisp/Sexp.html#read(java.lang.String)">read</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the S-expression contained in the specified string.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpConvertible.</B><B><A HREF="../../../danbikel/lisp/SexpConvertible.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts this object to an S-expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#get(int)">get</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>Sexp</code> at the specified index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#set(int, danbikel.lisp.Sexp)">set</A></B>(int&nbsp;index,
    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the element at <code>index</code> with <code>element</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#remove(int)">remove</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the element at <code>index</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#first()">first</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first element of this list (identical to calling
 <code>get(0)</code>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#last()">last</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last element of this list (identical to calling
 <code>get(size() - 1)</code>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#deepCopy()">deepCopy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a deep copy of this list, which means that a full copy of
 the tree of S-expressions held by this list is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Symbol.</B><B><A HREF="../../../danbikel/lisp/Symbol.html#deepCopy()">deepCopy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/lisp/package-summary.html">danbikel.lisp</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#add(danbikel.lisp.Sexp)">add</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Appends <code>sexp</code> to the end of this list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#add(int, danbikel.lisp.Sexp)">add</A></B>(int&nbsp;index,
    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds <code>sexp</code> at position <code>index</code>, shifting all
 elements to the right by one position to make room (an O(n) operation).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#set(int, danbikel.lisp.Sexp)">set</A></B>(int&nbsp;index,
    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the element at <code>index</code> with <code>element</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#indexOf(danbikel.lisp.Sexp)">indexOf</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;toFind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the index of the specified S-expresion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>SexpList.</B><B><A HREF="../../../danbikel/lisp/SexpList.html#contains(danbikel.lisp.Sexp)">contains</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;toFind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified S-expression is an element of this list.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Subclasses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/SubcatList.html" title="class in danbikel.parser">SubcatList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements subcats where requirements need to be met in the order
 in which they are added to this subcat (the strictest form of a subcat).
 </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Fields in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A> declared as <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpEvent.</B><B><A HREF="../../../danbikel/parser/SexpEvent.html#event">event</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The event stored by this instance.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenSubcatBag.</B><B><A HREF="../../../danbikel/parser/BrokenSubcatBag.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As per the contract of <code>Subcat</code>, this method returns a
 <code>Sexp</code> such that an equivalent <code>BrokenSubcatBag</code>
 object would result from the <A HREF="../../../danbikel/parser/BrokenSubcatBag.html#addAll(danbikel.lisp.SexpList)"><CODE>BrokenSubcatBag.addAll(SexpList)</CODE></A> method being
 invoked with this <code>Sexp</code> as its argument.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>CKYItem.</B><B><A HREF="../../../danbikel/parser/CKYItem.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the S-expression representation of the tree rooted at this
 chart item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>CKYItem.</B><B><A HREF="../../../danbikel/parser/CKYItem.html#toSexpInternal(boolean)">toSexpInternal</A></B>(boolean&nbsp;isHeadChild)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the S-expression representation of the tree rooted at this
 chart item (helper method invoked by <A HREF="../../../danbikel/parser/CKYItem.html#toSexp()"><CODE>CKYItem.toSexp()</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>CachingDecoderServer.</B><B><A HREF="../../../danbikel/parser/CachingDecoderServer.html#convertUnknownWord(danbikel.lisp.Symbol, int)">convertUnknownWord</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;originalWord,
                   int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns either the specified word untouched, or a 3-element list as would
 be created by <A HREF="../../../danbikel/parser/CachingDecoderServer.html#convertUnknownWords(danbikel.lisp.SexpList)"><CODE>CachingDecoderServer.convertUnknownWords(SexpList)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#parse(danbikel.lisp.SexpList)">parse</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the specified sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#parse(danbikel.lisp.SexpList, danbikel.lisp.SexpList)">parse</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the specified sentence using the supplied list of part-of-speech
 tags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#parse(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.parser.constraints.ConstraintSet)">parse</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags,
      <A HREF="../../../danbikel/parser/constraints/ConstraintSet.html" title="interface in danbikel.parser.constraints">ConstraintSet</A>&nbsp;constraints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the specified sentence using the supplied list of part-of-speech
 tags and the supplied set of parsing constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DecoderServer.</B><B><A HREF="../../../danbikel/parser/DecoderServer.html#convertUnknownWord(danbikel.lisp.Symbol, int)">convertUnknownWord</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;originalWord,
                   int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DecoderServerRemote.</B><B><A HREF="../../../danbikel/parser/DecoderServerRemote.html#convertUnknownWord(danbikel.lisp.Symbol, int)">convertUnknownWord</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;originalWord,
                   int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns either the specified word untouched, or a 3-element list as would
 be created by <A HREF="../../../danbikel/parser/DecoderServerRemote.html#convertUnknownWords(danbikel.lisp.SexpList)"><CODE>DecoderServerRemote.convertUnknownWords(SexpList)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/HeadFinder.html#addHeadInformation(danbikel.lisp.Sexp)">addHeadInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform head-finding in <code>tree</code>, augmenting nodes that are the
 head child of their parent by appending <A HREF="../../../danbikel/parser/HeadFinder.html#headSuffix()"><CODE>HeadFinder.headSuffix()</CODE></A>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>HeadTreeNode.</B><B><A HREF="../../../danbikel/parser/HeadTreeNode.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#parse(danbikel.lisp.SexpList)">parse</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the specified sentence, which can be in one of three formats.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#convertUnknownWords(danbikel.lisp.Sexp, danbikel.util.IntCounter)">convertUnknownWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts certain words (leaves) in the specified tree to their associated
 word-feature vectors.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpEvent.</B><B><A HREF="../../../danbikel/parser/SexpEvent.html#copySexpEvent()">copySexpEvent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a deep copy of the underlying <code>Sexp</code> of this event.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpEvent.</B><B><A HREF="../../../danbikel/parser/SexpEvent.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Sexp</code> contained in this event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SexpSubcatEvent.</B><B><A HREF="../../../danbikel/parser/SexpSubcatEvent.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this event has no subcat, then this method simply returns the backing
 <code>Sexp</code>; otherwise, this method returns a <code>SexpList</code>
 of the form <code>(sexp&nbsp;subcat)</code>, where <code>sexp</code>
 is the <code>Sexp</code> component(s) of this event and <code>subcat</code>
 is the result of calling <code>subcat.toSexp()</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Subcat.</B><B><A HREF="../../../danbikel/parser/Subcat.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a list view of the information contained in this subcat,
 such that an equivalent subcat would result if a new
 <code>Subcat</code> object of this run-time type were constructed
 and its <A HREF="../../../danbikel/parser/Subcat.html#addAll(danbikel.lisp.SexpList)"><CODE>Subcat.addAll(SexpList)</CODE></A> method were invoked with the
 list returned by this method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SubcatBag.</B><B><A HREF="../../../danbikel/parser/SubcatBag.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As per the contract of <code>Subcat</code>, this method returns a
 <code>Sexp</code> such that an equivalent <code>SubcatBag</code> object
 would result from the <A HREF="../../../danbikel/parser/SubcatBag.html#addAll(danbikel.lisp.SexpList)"><CODE>SubcatBag.addAll(SexpList)</CODE></A> method being invoked with
 this <code>Sexp</code> as its argument.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SubcatList.</B><B><A HREF="../../../danbikel/parser/SubcatList.html#get(int)">get</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>SubcatList.</B><B><A HREF="../../../danbikel/parser/SubcatList.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs in the specified tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</A></B>(<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Word.</B><B><A HREF="../../../danbikel/parser/Word.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>BaseNPAwareShifter.</B><B><A HREF="../../../danbikel/parser/BaseNPAwareShifter.html#shift(danbikel.parser.TrainerEvent, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">shift</A></B>(<A HREF="../../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser">TrainerEvent</A>&nbsp;event,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;list,
      <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The previous modifier is <i>not</i> shifted into the history if the
 current parent (as determined by <A HREF="../../../danbikel/parser/TrainerEvent.html#parent()"><CODE>TrainerEvent.parent()</CODE></A>) is a base
 NP and the previous modifier is punctuation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BaseNPAwareShifter.</B><B><A HREF="../../../danbikel/parser/BaseNPAwareShifter.html#skip(danbikel.parser.Item, danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/parser/Item.html" title="class in danbikel.parser">Item</A>&nbsp;item,
     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The previous modifier is skipped (not included in the construction of the
 history) if the current parent (as determined by <A HREF="../../../danbikel/parser/CKYItem.html#label()"><CODE>CKYItem.label()</CODE></A>)
 is a base NP and the previous modifier is punctuation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#isPuncRaiseWord(danbikel.lisp.Sexp)">isPuncRaiseWord</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified word was raised as part of the
 punctuation-raising procedure performed during training.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs post-processing on a sentence that has been parsed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#restoreOriginalWords(danbikel.lisp.Sexp, int)">restoreOriginalWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                     int&nbsp;wordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restores the original words in the current sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#restorePrunedWords(danbikel.lisp.Sexp)">restorePrunedWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restores pruned words to a parsed sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B>Decoder.</B><B><A HREF="../../../danbikel/parser/Decoder.html#restorePrunedWordsRecursive(danbikel.lisp.Sexp, int)">restorePrunedWordsRecursive</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                            int&nbsp;wordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The recursive helper method for <A HREF="../../../danbikel/parser/Decoder.html#restorePrunedWords(danbikel.lisp.Sexp)"><CODE>Decoder.restorePrunedWords(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DefaultShifter.</B><B><A HREF="../../../danbikel/parser/DefaultShifter.html#shift(danbikel.parser.TrainerEvent, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">shift</A></B>(<A HREF="../../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser">TrainerEvent</A>&nbsp;event,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;list,
      <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>DefaultShifter.</B><B><A HREF="../../../danbikel/parser/DefaultShifter.html#skip(danbikel.parser.Item, danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/parser/Item.html" title="class in danbikel.parser">Item</A>&nbsp;item,
     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B>DefaultWordFactory.</B><B><A HREF="../../../danbikel/parser/DefaultWordFactory.html#get(danbikel.lisp.Sexp)">get</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>EMParser.</B><B><A HREF="../../../danbikel/parser/EMParser.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instead of simply invoking the <A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)"><CODE>Training.preProcess(Sexp)</CODE></A> method,
 this method selectively invokes only some of the preprocessing methods of
 <A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser"><CODE>Training</CODE></A>, so as to leave the rest of the transformations
 unconstrained.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/HeadFinder.html#findHead(danbikel.lisp.Sexp)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the production at the root of the specified subtree. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/HeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs &rarr; rhs</code>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/HeadFinder.html#addHeadInformation(danbikel.lisp.Sexp)">addHeadInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform head-finding in <code>tree</code>, augmenting nodes that are the
 head child of their parent by appending <A HREF="../../../danbikel/parser/HeadFinder.html#headSuffix()"><CODE>HeadFinder.headSuffix()</CODE></A>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#convertUnknownWords(danbikel.lisp.Sexp, danbikel.util.IntCounter)">convertUnknownWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts certain words (leaves) in the specified tree to their associated
 word-feature vectors.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/parser/constraints/ConstraintSet.html" title="interface in danbikel.parser.constraints">ConstraintSet</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#getConstraintsFromTree(danbikel.lisp.Sexp)">getConstraintsFromTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After <A HREF="../../../danbikel/parser/Parser.html#convertUnknownWords(danbikel.lisp.Sexp, danbikel.util.IntCounter)">converting
 unknown words</A> in the specified parse tree, this method constructs
 a constraint set using the method <A HREF="../../../danbikel/parser/constraints/ConstraintSets.html#get(java.lang.Object)"><CODE>ConstraintSets.get(Object)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#wordTagList(danbikel.lisp.Sexp)">wordTagList</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified S-expression is a list of length two
 whose first element is a symbol and whose second element is a list
 of one or more symbols.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#getWordsFromTree(danbikel.lisp.Sexp)">getWordsFromTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new list containing the word symbols from the specified tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#getWordsFromTree(danbikel.lisp.SexpList, danbikel.lisp.Sexp)">getWordsFromTree</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;wordList,
                 <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the words of the sentence to be parsed from the specified parse
 tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B>Parser.</B><B><A HREF="../../../danbikel/parser/Parser.html#getTagListsFromTree(danbikel.lisp.Sexp)">getTagListsFromTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collects a list of symbols that are the part-of-speech tags (preterminals)
 of the specified tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>SexpEvent.</B><B><A HREF="../../../danbikel/parser/SexpEvent.html#setSexp(danbikel.lisp.Sexp)">setSexp</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the backing <tt>Sexp</tt> of this object to be the specified
 <tt>Sexp</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Shift.</B><B><A HREF="../../../danbikel/parser/Shift.html#shift(danbikel.parser.TrainerEvent, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">shift</A></B>(<A HREF="../../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser">TrainerEvent</A>&nbsp;event,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;list,
      <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shifts the previously-generated modifier label into the history.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Shift.</B><B><A HREF="../../../danbikel/parser/Shift.html#skip(danbikel.parser.Item, danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/parser/Item.html" title="class in danbikel.parser">Item</A>&nbsp;item,
     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the previously-generated modifier should be skipped
 when constructing a history for the specified chart item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Shifter.</B><B><A HREF="../../../danbikel/parser/Shifter.html#shift(danbikel.parser.TrainerEvent, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">shift</A></B>(<A HREF="../../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser">TrainerEvent</A>&nbsp;event,
      <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;list,
      <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses the internal <A HREF="../../../danbikel/parser/Shifter.html" title="class in danbikel.parser"><CODE>Shifter</CODE></A> instance to shift the newly-generated
 (and therefore previously-generated) modifier into the history, which is a
 <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp"><CODE>SexpList</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Shifter.</B><B><A HREF="../../../danbikel/parser/Shifter.html#skip(danbikel.parser.CKYItem, danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/parser/CKYItem.html" title="class in danbikel.parser">CKYItem</A>&nbsp;item,
     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;prevMod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses the internal <A HREF="../../../danbikel/parser/Shifter.html" title="class in danbikel.parser"><CODE>Shifter</CODE></A> instance to determine whether the
 specified modifier should be skipped when constructing a history for the
 specified chart item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Trainer.</B><B><A HREF="../../../danbikel/parser/Trainer.html#collectStats(danbikel.lisp.Sexp, danbikel.parser.HeadTreeNode, boolean)">collectStats</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;orig,
             <A HREF="../../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser">HeadTreeNode</A>&nbsp;tree,
             boolean&nbsp;isRoot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collects the statistics from the specified tree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is valid.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#skip(danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is to be skipped when training.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs in the specified tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#getTag(danbikel.lisp.Sexp)">getTag</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the component of the preterminal tree that corresponds to the
 part of speech tag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Word</code> object from the specified preterminal
 subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for the current
 language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">getTraceIndex</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
              <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of a trace for the specified null element preterminal.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified preterminal is that of a verb.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Word.</B><B><A HREF="../../../danbikel/parser/Word.html#checkSexp(danbikel.lisp.Sexp)">checkSexp</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks that the S-expression passed to <A HREF="../../../danbikel/parser/Word.html#Word(danbikel.lisp.Sexp)"><CODE>Word.Word(Sexp)</CODE></A> is the right
 format. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B>WordFactory.</B><B><A HREF="../../../danbikel/parser/WordFactory.html#get(danbikel.lisp.Sexp)">get</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object from the specified S-expression, which
 must be a list of length 2 or greater, where the first two elements are
 symbols.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B>Words.</B><B><A HREF="../../../danbikel/parser/Words.html#get(danbikel.lisp.Sexp)">get</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> instance constructed from the specified
 S-expression.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/package-summary.html">danbikel.parser</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/GapEvent.html#GapEvent(danbikel.lisp.Sexp)">GapEvent</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contructs a new object from the specified S-expression.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/HeadEvent.html#HeadEvent(danbikel.lisp.Sexp)">HeadEvent</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contructs a new object from the specified S-expression.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/HeadTreeNode.html#HeadTreeNode(danbikel.lisp.Sexp)">HeadTreeNode</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new instance from the specified parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/ModifierEvent.html#ModifierEvent(danbikel.lisp.Sexp)">ModifierEvent</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new object from the specified S-expression. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/SexpEvent.html#SexpEvent(danbikel.lisp.Sexp)">SexpEvent</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>SexpEvent</code> using the specified S-expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/SymbolPair.html#SymbolPair(danbikel.lisp.Sexp)">SymbolPair</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <A HREF="../../../danbikel/parser/SymbolPair.html" title="class in danbikel.parser"><CODE>SymbolPair</CODE></A> from the first two symbols in the specified
 list.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/Word.html#Word(danbikel.lisp.Sexp)">Word</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a word using the symbols contained in the specified
 S-expression, which must be a list of at least two symbols.  </TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.arabic"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/arabic/package-summary.html">danbikel.parser.arabic</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/arabic/package-summary.html">danbikel.parser.arabic</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#transformTags(danbikel.lisp.Sexp)">transformTags</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does an in-place transformation of the part-of-speech tags in the specified
 tree.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/arabic/package-summary.html">danbikel.parser.arabic</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/arabic/HeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs -> rhs</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified tree has a root label with a print name equal to
 <tt>&quot;X&quot;</tt>, then this method returns <code>false</code>;
 otherwise, this method returns the value of the default implementation in
 the superclass with the specified tree
 (<code>super.isValidTree(tree)</code>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#transformTags(danbikel.lisp.Sexp)">transformTags</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does an in-place transformation of the part-of-speech tags in the specified
 tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#hasPossessiveChild(danbikel.lisp.Sexp)">hasPossessiveChild</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override this method so that it always returns <code>false</code>,
 so that the default implementation of <code>addBaseNPs(Sexp)<code>
 never considers an <tt>NP</tt> to be a possessive <tt>NP</tt>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/arabic/Training.html#canonicalizeNonterminals(danbikel.lisp.Sexp)">canonicalizeNonterminals</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For arabic, we do <i>not</i> want to transform preterminals
 (parts of speech) to their canonical forms, so this method is overridden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/arabic/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> represents a preterminal
 subtree (part-of-speech tag and word).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/arabic/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents a
 preterminal whose terminal element is the null element
 (<code>&quot;-NONE-&quot;</code>) for the Penn Arabic Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/arabic/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression is a preterminal
 whose part of speech is <code>&quot;,&quot;</code> or
 <code>&quot;:&quot;</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/arabic/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/arabic/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>preterminal</code> represents a
 terminal with one of the following parts of speech: <tt>VB, VBD, VBG,
 VBN, VBP</tt> or <tt>VBZ</tt>.  </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/arabic/package-summary.html">danbikel.parser.arabic</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/arabic/HeadFinder.html#HeadFinder(danbikel.lisp.Sexp)">HeadFinder</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an Arabic head-finding object with the specified head table.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.chinese"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/chinese/package-summary.html">danbikel.parser.chinese</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/chinese/package-summary.html">danbikel.parser.chinese</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NPArgThreadTraining.</B><B><A HREF="../../../danbikel/parser/chinese/NPArgThreadTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs all the preprocessing setps of the overridden <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><CODE>AbstractTraining.preProcess(Sexp)</CODE></A> method of the superclass, and then provides an
 additional preprocessing step by invoking <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)"><CODE>AbstractTraining.threadNPArgAugmentations(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NoNPBTraining.</B><B><A HREF="../../../danbikel/parser/chinese/NoNPBTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override this method from the default implementation so that
 it does nothing.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/chinese/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>AbstractTraining.relabelSubjectlessSentences(Sexp)</CODE></A> so
 that we can make the definition of a subjectless sentence
 slightly more restrictive: a subjectless sentence not only must
 have a null-element child that is marked with the subject
 augmentation, but also its head must be a <tt>VP</tt> (this is
 Mike Collins&rsquo; definition of a subjectless sentence).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/chinese/Training.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method to un-do the transformation provided by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>AbstractTraining.repairBaseNPs(Sexp)</CODE></A> (for inclusion
 in an overridden definition of
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><CODE>AbstractTraining.postProcess(Sexp)</CODE></A>,
 but currently unused by this class).</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/chinese/package-summary.html">danbikel.parser.chinese</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/chinese/HeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs -> rhs</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NPArgThreadTraining.</B><B><A HREF="../../../danbikel/parser/chinese/NPArgThreadTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs all the preprocessing setps of the overridden <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><CODE>AbstractTraining.preProcess(Sexp)</CODE></A> method of the superclass, and then provides an
 additional preprocessing step by invoking <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)"><CODE>AbstractTraining.threadNPArgAugmentations(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NoNPBTraining.</B><B><A HREF="../../../danbikel/parser/chinese/NoNPBTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override this method from the default implementation so that
 it does nothing.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/chinese/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>AbstractTraining.relabelSubjectlessSentences(Sexp)</CODE></A> so
 that we can make the definition of a subjectless sentence
 slightly more restrictive: a subjectless sentence not only must
 have a null-element child that is marked with the subject
 augmentation, but also its head must be a <tt>VP</tt> (this is
 Mike Collins&rsquo; definition of a subjectless sentence).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/chinese/Training.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method to un-do the transformation provided by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>AbstractTraining.repairBaseNPs(Sexp)</CODE></A> (for inclusion
 in an overridden definition of
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><CODE>AbstractTraining.postProcess(Sexp)</CODE></A>,
 but currently unused by this class).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/chinese/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> represents a preterminal
 subtree (part-of-speech tag and word).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/chinese/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents a
 preterminal whose terminal element is the null element
 (<code>&quot;-NONE-&quot;</code>) for the Chinese Treebank.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/chinese/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression is a preterminal
 whose part of speech is <code>&quot;,&quot;</code> or
 <code>&quot;.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/chinese/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/chinese/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>preterminal</code> represents a
 terminal with one of the following parts of speech: <tt>VB, VBD, VBG,
 VBN, VBP</tt> or <tt>VBZ</tt>.  </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/chinese/package-summary.html">danbikel.parser.chinese</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/chinese/HeadFinder.html#HeadFinder(danbikel.lisp.Sexp)">HeadFinder</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an Chinese head-finding object with the specified head table.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.constraints"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/constraints/package-summary.html">danbikel.parser.constraints</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/constraints/package-summary.html">danbikel.parser.constraints</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>LexTreeConstraint.</B><B><A HREF="../../../danbikel/parser/constraints/LexTreeConstraint.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>PartialLexTreeConstraint.</B><B><A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>PartialTreeConstraint.</B><B><A HREF="../../../danbikel/parser/constraints/PartialTreeConstraint.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a symbolic expression representing the tree of constraints rooted
 at this constraint (intended for debugging purposes).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>UnlexTreeConstraint.</B><B><A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraint.html#toSexp()">toSexp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a symbolic expression version of the constraint tree rooted
 at this constraint.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/constraints/package-summary.html">danbikel.parser.constraints</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>LexTreeConstraintSet.</B><B><A HREF="../../../danbikel/parser/constraints/LexTreeConstraintSet.html#buildConstraintSet(danbikel.lisp.Sexp)">buildConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds the constraint tree from a lexicalized version of the specified
 unlexicalized parse tree (exicalization performed by the current
 <A HREF="../../../danbikel/parser/Language.html#headFinder()">head finder</A>). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>PartialLexTreeConstraintSet.</B><B><A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraintSet.html#buildConstraintSet(danbikel.lisp.Sexp)">buildConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds the constraint tree from the specified unlexicalized parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>PartialTreeConstraintSet.</B><B><A HREF="../../../danbikel/parser/constraints/PartialTreeConstraintSet.html#buildConstraintSet(danbikel.lisp.Sexp)">buildConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds the constraint tree from the specified unlexicalized parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>UnlexTreeConstraintSet.</B><B><A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraintSet.html#buildConstraintSet(danbikel.lisp.Sexp)">buildConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds the constraint tree from the specified unlexicalized parse tree.
 </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/constraints/package-summary.html">danbikel.parser.constraints</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/LexTreeConstraint.html#LexTreeConstraint(danbikel.lisp.Sexp)">LexTreeConstraint</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a tree of constraints that is isomorphic to the specified
 parse tree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/LexTreeConstraint.html#LexTreeConstraint(danbikel.parser.constraints.LexTreeConstraint, danbikel.lisp.Sexp, danbikel.util.IntCounter, danbikel.parser.HeadFinder)">LexTreeConstraint</A></B>(<A HREF="../../../danbikel/parser/constraints/LexTreeConstraint.html" title="class in danbikel.parser.constraints">LexTreeConstraint</A>&nbsp;parent,
                  <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                  <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx,
                  <A HREF="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</A>&nbsp;headFinder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a tree of constraints that is isomorphic to the specified
 parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/LexTreeConstraintSet.html#LexTreeConstraintSet(danbikel.lisp.Sexp)">LexTreeConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new set of constraints according to a lexicalized version of
 the specified unlexicalized tree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html#PartialLexTreeConstraint(danbikel.lisp.Sexp)">PartialLexTreeConstraint</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a tree of constraints given the specified parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html#PartialLexTreeConstraint(danbikel.parser.constraints.PartialLexTreeConstraint, danbikel.lisp.Sexp, danbikel.util.IntCounter, danbikel.parser.HeadFinder)">PartialLexTreeConstraint</A></B>(<A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html" title="class in danbikel.parser.constraints">PartialLexTreeConstraint</A>&nbsp;parent,
                         <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                         <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx,
                         <A HREF="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</A>&nbsp;headFinder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A helper constructor used by <A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html#PartialLexTreeConstraint(danbikel.lisp.Sexp)"><CODE>PartialLexTreeConstraint.PartialLexTreeConstraint(Sexp)</CODE></A>
 to construct an entire tree of constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraintSet.html#PartialLexTreeConstraintSet(danbikel.lisp.Sexp)">PartialLexTreeConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a set of <A HREF="../../../danbikel/parser/constraints/PartialLexTreeConstraint.html" title="class in danbikel.parser.constraints"><CODE>PartialLexTreeConstraint</CODE></A> objects forming a tree
 structure from the specified syntactic tree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialTreeConstraint.html#PartialTreeConstraint(danbikel.lisp.Sexp)">PartialTreeConstraint</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a tree of constraints rooted at the specified syntactic tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialTreeConstraint.html#PartialTreeConstraint(danbikel.parser.constraints.PartialTreeConstraint, danbikel.lisp.Sexp, danbikel.util.IntCounter)">PartialTreeConstraint</A></B>(<A HREF="../../../danbikel/parser/constraints/PartialTreeConstraint.html" title="class in danbikel.parser.constraints">PartialTreeConstraint</A>&nbsp;parent,
                      <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                      <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A helper constructor for constructing a tree of constraints rooted
 at the specified subtree with the specified <code>parent</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/PartialTreeConstraintSet.html#PartialTreeConstraintSet(danbikel.lisp.Sexp)">PartialTreeConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of partial tree constraints whose tree structure is
 isomorphic to the specified (possibly partial) syntactic tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraint.html#UnlexTreeConstraint(danbikel.lisp.Sexp)">UnlexTreeConstraint</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the root constraint of a tree of constraints isomorphic to the
 specified unlexicalized tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraint.html#UnlexTreeConstraint(danbikel.parser.constraints.UnlexTreeConstraint, danbikel.lisp.Sexp, danbikel.util.IntCounter)">UnlexTreeConstraint</A></B>(<A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraint.html" title="class in danbikel.parser.constraints">UnlexTreeConstraint</A>&nbsp;parent,
                    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    <A HREF="../../../danbikel/util/IntCounter.html" title="class in danbikel.util">IntCounter</A>&nbsp;currWordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a tree of constraints isomorphic to the specified unlexicalized
 syntactic tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/constraints/UnlexTreeConstraintSet.html#UnlexTreeConstraintSet(danbikel.lisp.Sexp)">UnlexTreeConstraintSet</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a constraint set derived from the specified unlexicalized
 syntactic tree.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.english"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/english/package-summary.html">danbikel.parser.english</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/english/package-summary.html">danbikel.parser.english</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marks certain nodes as arguments by appending a suffix to their
 respective labels.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#fixSubjectlessSentences(danbikel.lisp.Sexp)">fixSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method has been written to do nothing to the specified tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;De-transforms NPs that were transformed by the
 <A HREF="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.repairBaseNPs(Sexp)</CODE></A> method.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NPArgThreadTraining.</B><B><A HREF="../../../danbikel/parser/english/NPArgThreadTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../../danbikel/parser/english/Training.html#preProcess(danbikel.lisp.Sexp)"><CODE>Training.preProcess(danbikel.lisp.Sexp)</CODE></A>, except
 that <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)"><CODE>AbstractTraining.threadNPArgAugmentations(danbikel.lisp.Sexp)</CODE></A> is invoked
 after all other preprocessing methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A> so
 that we can make the definition of a subjectless sentence
 slightly more restrictive: a subjectless sentence not only must
 have a null-element child that is marked with the subject
 augmentation, but also its head must be a <tt>VP</tt> (this is
 Mike Collins' definition of a subjectless sentence).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#fixSubjectlessSentences(danbikel.lisp.Sexp)">fixSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;De-transforms sentence labels changed by <A HREF="../../../danbikel/parser/english/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A> when the subjectless sentence node has
 children prior to its head child that are arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to un-do the transformation performed by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>AbstractTraining.repairBaseNPs(Sexp)</CODE></A>, in which sentential nodes that occur to the right of
 the head child of a base NP are moved to become immediate right siblings of
 the base NP; accordingly, this method moves all such sentential nodes that
 occur immediately to the right of a base NP to be the rightmost child under
 that base NP.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/english/package-summary.html">danbikel.parser.english</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>BrokenHeadFinder.</B><B><A HREF="../../../danbikel/parser/english/BrokenHeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs -> rhs</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marks certain nodes as arguments by appending a suffix to their
 respective labels.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#fixSubjectlessSentences(danbikel.lisp.Sexp)">fixSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method has been written to do nothing to the specified tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;De-transforms NPs that were transformed by the
 <A HREF="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.repairBaseNPs(Sexp)</CODE></A> method.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTraining.</B><B><A HREF="../../../danbikel/parser/english/BrokenTraining.html#needToAddNormalNPLevel(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">needToAddNormalNPLevel</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
                       int&nbsp;parentIdx,
                       <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The following method has been overridden so that the two unpublished
 conditions under which one needs to add a normal NP level are overlooked.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTreebank.</B><B><A HREF="../../../danbikel/parser/english/BrokenTreebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> represents a preterminal
 subtree (part-of-speech tag and word).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTreebank.</B><B><A HREF="../../../danbikel/parser/english/BrokenTreebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents a
 preterminal whose terminal element is the null element
 (<code>&quot;-NONE-&quot;</code>) for the Penn Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTreebank.</B><B><A HREF="../../../danbikel/parser/english/BrokenTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression is a preterminal
 whose part of speech is <code>&quot;,&quot;</code> or
 <code>&quot;:&quot;</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTreebank.</B><B><A HREF="../../../danbikel/parser/english/BrokenTreebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>BrokenTreebank.</B><B><A HREF="../../../danbikel/parser/english/BrokenTreebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>preterminal</code> represents a
 terminal with one of the following parts of speech: <tt>VB, VBD, VBG,
 VBN, VBP</tt> or <tt>VBZ</tt>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>HeadFinder.</B><B><A HREF="../../../danbikel/parser/english/HeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs -> rhs</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>NPArgThreadTraining.</B><B><A HREF="../../../danbikel/parser/english/NPArgThreadTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../../danbikel/parser/english/Training.html#preProcess(danbikel.lisp.Sexp)"><CODE>Training.preProcess(danbikel.lisp.Sexp)</CODE></A>, except
 that <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)"><CODE>AbstractTraining.threadNPArgAugmentations(danbikel.lisp.Sexp)</CODE></A> is invoked
 after all other preprocessing methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We override <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A> so
 that we can make the definition of a subjectless sentence
 slightly more restrictive: a subjectless sentence not only must
 have a null-element child that is marked with the subject
 augmentation, but also its head must be a <tt>VP</tt> (this is
 Mike Collins' definition of a subjectless sentence).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#fixSubjectlessSentences(danbikel.lisp.Sexp)">fixSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;De-transforms sentence labels changed by <A HREF="../../../danbikel/parser/english/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A> when the subjectless sentence node has
 children prior to its head child that are arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#unrepairBaseNPs(danbikel.lisp.Sexp)">unrepairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to un-do the transformation performed by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>AbstractTraining.repairBaseNPs(Sexp)</CODE></A>, in which sentential nodes that occur to the right of
 the head child of a base NP are moved to become immediate right siblings of
 the base NP; accordingly, this method moves all such sentential nodes that
 occur immediately to the right of a base NP to be the rightmost child under
 that base NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>Training.</B><B><A HREF="../../../danbikel/parser/english/Training.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/english/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> represents a preterminal
 subtree (part-of-speech tag and word).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/english/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents a
 preterminal whose terminal element is the null element
 (<code>&quot;-NONE-&quot;</code>) for the Penn Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/english/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression is a preterminal
 whose part of speech is <code>&quot;,&quot;</code> or
 <code>&quot;:&quot;</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/english/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>Treebank.</B><B><A HREF="../../../danbikel/parser/english/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>preterminal</code> represents a
 terminal with one of the following parts of speech: <tt>VB, VBD, VBG,
 VBN, VBP</tt> or <tt>VBZ</tt>.  </TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/english/package-summary.html">danbikel.parser.english</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/english/BrokenHeadFinder.html#BrokenHeadFinder(danbikel.lisp.Sexp)">BrokenHeadFinder</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an English head-finding object with the specified head table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/english/HeadFinder.html#HeadFinder(danbikel.lisp.Sexp)">HeadFinder</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an English head-finding object with the specified head table.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.lang"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/lang/package-summary.html">danbikel.parser.lang</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/lang/package-summary.html">danbikel.parser.lang</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractHeadFinder.</B><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#addHeadInformation(danbikel.lisp.Sexp)">addHeadInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform head-finding in <code>tree</code>, augmenting nodes that
 are the head children of their respective parents.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#transformSubjectNTs(danbikel.lisp.Sexp)">transformSubjectNTs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
              int&nbsp;parentIdx,
              <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)">threadNPArgAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</A></B>(<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/lang/package-summary.html">danbikel.parser.lang</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>AbstractHeadFinder.</B><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#findHead(danbikel.lisp.Sexp)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the production at the root of the specified subtree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B>AbstractHeadFinder.</B><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#findHead(danbikel.lisp.Sexp, danbikel.lisp.Symbol, danbikel.lisp.SexpList)">findHead</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
         <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;lhs,
         <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the head for the grammar production <code>lhs -> rhs</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractHeadFinder.</B><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#addHeadInformation(danbikel.lisp.Sexp)">addHeadInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform head-finding in <code>tree</code>, augmenting nodes that
 are the head children of their respective parents.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>AbstractHeadFinder.</B><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#readHeadTable(danbikel.lisp.Sexp)">readHeadTable</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the head table contained in the specified S-expression.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> is a preterminal (the base
 case) or is a list with the first element of type <code>Symbol</code> (the
 node label) and subsequent elements are valid trees (the recursive case).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isAllNodesToPrune(danbikel.lisp.Sexp)">isAllNodesToPrune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether all words or preterminals of this tree are to be pruned.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#skip(danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is to be skipped when training.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#transformSubjectNTs(danbikel.lisp.Sexp)">transformSubjectNTs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#collectPreterms(java.util.Set, danbikel.lisp.Sexp)">collectPreterms</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A>&nbsp;preterms,
                <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds all preterminal subtrees to the specified set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)">hasGap</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
       <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;root,
       <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/ArrayList.html" title="class or interface in java.util">ArrayList</A>&nbsp;indexStack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns -1 if <code>tree</code> has no gap (trace), or the index of the
 trace otherwise.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#unaryProductionsToNull(danbikel.lisp.Sexp)">unaryProductionsToNull</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified subtree consists solely of unary productions
 going to a null element terminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
              int&nbsp;parentIdx,
              <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)">threadNPArgAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#needToAddNormalNPLevel(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">needToAddNormalNPLevel</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
                       int&nbsp;parentIdx,
                       <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if a unary NP needs to be added above the
 specified base NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isCoordinatedPhrase(danbikel.lisp.Sexp, int)">isCoordinatedPhrase</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    int&nbsp;headIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if a non-head child of the specified
 tree is a conjunction, and that conjunction is either post-head
 but non-final, or immediately pre-head but non-initial (where
 &quot;immediately pre-head&quot; means &quot;at the first index
 less than <code>headIdx</code> that is not punctuation, as determined
 by <A HREF="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)"><CODE>Treebank.isPunctuation(Symbol)</CODE></A>).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasPossessiveChild(danbikel.lisp.Sexp)">hasPossessiveChild</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> contains a child for which
 <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A> returns
 <code>true</code>, <code>false</code> otherwise.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeOnlyChildBaseNPs(danbikel.lisp.Sexp)">removeOnlyChildBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle case where an NP dominates a base NP and has no other children
 (the base NP is an "only child" of the dominating NP).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B>AbstractTraining.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#canonicalizeNonterminals(danbikel.lisp.Sexp)">canonicalizeNonterminals</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies each nonterminal in the specified tree to be its canonical
 version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getTag(danbikel.lisp.Sexp)">getTag</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the component of the preterminal tree that corresponds to the
 part of speech tag.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Word</code> object from the specified preterminal
 subtree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for this
 language&rsquo;s Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">getTraceIndex</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
              <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of a trace for the specified null element preterminal.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified preterminal is that of a verb.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B>AbstractTreebank.</B><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Constructors in <A HREF="../../../danbikel/parser/lang/package-summary.html">danbikel.parser.lang</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.html#AbstractHeadFinder(danbikel.lisp.Sexp)">AbstractHeadFinder</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;headTableSexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a head-finding object with the specified head table.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="danbikel.parser.util"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
Uses of <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> in <A HREF="../../../danbikel/parser/util/package-summary.html">danbikel.parser.util</A></FONT></TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/util/package-summary.html">danbikel.parser.util</A> that return <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#removePreterms(danbikel.lisp.SexpList, danbikel.lisp.Sexp, int)">removePreterms</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;words,
               <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
               int&nbsp;wordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes preterminals from the specified tree that are not found in
 the specified list of words.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#removeChildlessNodes(danbikel.lisp.Sexp)">removeChildlessNodes</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes interior nodes of the specified tree that are not preterminals and
 that have no children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectLeaves(danbikel.lisp.Sexp)">collectLeaves</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>SexpList</code> that contains all the leaves of the
 specified parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectTaggedWords(danbikel.lisp.Sexp)">collectTaggedWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>SexpList</code> that contains all the words of the
 specified parse tree as well as their part of speech tags, where each
 word is its own <code>SexpList</code> of the form <tt>(word (tag))</tt>.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TD COLSPAN=2>Methods in <A HREF="../../../danbikel/parser/util/package-summary.html">danbikel.parser.util</A> with parameters of type <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#findConstituents(java.lang.String, danbikel.lisp.Sexp)">findConstituents</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>&nbsp;chartFilename,
                 <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;goldTree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out to <code>System.err</code> which constituents of the specified
 gold-standard parse tree were found by the parser, according to its output
 chart file.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#findConstituents(boolean, danbikel.parser.Chart, danbikel.parser.CKYItem, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">findConstituents</A></B>(boolean&nbsp;downcaseWords,
                 <A HREF="../../../danbikel/parser/Chart.html" title="class in danbikel.parser">Chart</A>&nbsp;chart,
                 <A HREF="../../../danbikel/parser/CKYItem.html" title="class in danbikel.parser">CKYItem</A>&nbsp;topRankedItem,
                 <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                 <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;goldTree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out to <code>System.err</code> which constituents of the specified
 gold-standard parse tree were found by the parser, according to the
 specified chart.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#findConstituents(java.lang.String, boolean, danbikel.parser.Chart, danbikel.parser.CKYItem, danbikel.lisp.SexpList, danbikel.lisp.Sexp)">findConstituents</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>&nbsp;prefix,
                 boolean&nbsp;downcaseWords,
                 <A HREF="../../../danbikel/parser/Chart.html" title="class in danbikel.parser">Chart</A>&nbsp;chart,
                 <A HREF="../../../danbikel/parser/CKYItem.html" title="class in danbikel.parser">CKYItem</A>&nbsp;topRankedItem,
                 <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                 <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;goldTree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out to <code>System.err</code> which constituents of the specified
 gold-standard parse tree were found by the parser, according to the
 specified chart.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#replaceWords(boolean, danbikel.lisp.Sexp, danbikel.lisp.SexpList)">replaceWords</A></B>(boolean&nbsp;downcaseWords,
             <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
             <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#downcaseWords(danbikel.lisp.Sexp)">downcaseWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#removePreterms(danbikel.lisp.SexpList, danbikel.lisp.Sexp, int)">removePreterms</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;words,
               <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
               int&nbsp;wordIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes preterminals from the specified tree that are not found in
 the specified list of words.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>DebugChart.</B><B><A HREF="../../../danbikel/parser/util/DebugChart.html#removeChildlessNodes(danbikel.lisp.Sexp)">removeChildlessNodes</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes interior nodes of the specified tree that are not preterminals and
 that have no children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectLeaves(danbikel.lisp.Sexp)">collectLeaves</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>SexpList</code> that contains all the leaves of the
 specified parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectTaggedWords(danbikel.lisp.Sexp)">collectTaggedWords</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>SexpList</code> that contains all the words of the
 specified parse tree as well as their part of speech tags, where each
 word is its own <code>SexpList</code> of the form <tt>(word (tag))</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/ArrayList.html" title="class or interface in java.util">ArrayList</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectWordObjects(danbikel.lisp.Sexp)">collectWordObjects</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectNonterminals(danbikel.parser.CountsTable, danbikel.lisp.Sexp, boolean)">collectNonterminals</A></B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;counts,
                    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    boolean&nbsp;includeTags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the nonterminals in the specified tree to the specified set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#collectTags(danbikel.parser.CountsTable, danbikel.lisp.Sexp)">collectTags</A></B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;counts,
            <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the part of speech tags in the specified tree to the specified set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B>Util.</B><B><A HREF="../../../danbikel/parser/util/Util.html#prettyPrint(danbikel.lisp.Sexp)">prettyPrint</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string containing the pretty-printed version of the specified
 parse tree.</TD>
</TR>
</TABLE>
&nbsp;
<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp"><FONT CLASS="NavBarFont1"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Use</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sexp.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a>
</BODY>
</HTML>
