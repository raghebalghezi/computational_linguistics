<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_02) on Tue Sep 27 13:34:36 EDT 2005 -->
<TITLE>
AbstractTraining (Dan Bikel's Parsing Engine)
</TITLE>

<META NAME="keywords" CONTENT="danbikel.parser.lang.AbstractTraining class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AbstractTraining (Dan Bikel's Parsing Engine)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractTraining.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.HeadFindInstruction.html" title="class in danbikel.parser.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractTraining.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
danbikel.parser.lang</FONT>
<BR>
Class AbstractTraining</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>danbikel.parser.lang.AbstractTraining</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A>, <A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../danbikel/parser/english/BrokenTraining.html" title="class in danbikel.parser.english">BrokenTraining</A>, <A HREF="../../../danbikel/parser/arabic/Training.html" title="class in danbikel.parser.arabic">Training</A>, <A HREF="../../../danbikel/parser/chinese/Training.html" title="class in danbikel.parser.chinese">Training</A>, <A HREF="../../../danbikel/parser/english/Training.html" title="class in danbikel.parser.english">Training</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>AbstractTraining</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A><DT>implements <A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A></DL>

<P>
Provides methods for language-specific preprocessing of training
 parse trees.  The primary method to be invoked from this class is
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><CODE>preProcess(Sexp)</CODE></A>.  Additionally, as this class contains or
 has access to appropriate preprocessing data and methods, it also
 contains a crucial method to be used for post-processing, to
 &quot;undo&quot; what it has done during preprocessing after
 decoding.  This post-processing method is <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><CODE>postProcess(Sexp)</CODE></A>, and is invoked by default by the
 <code>Decoder</code>.
 <p>
 <b>Concurrency note</b>: As training is typically a sequential
 process, with very few noted exceptions, <i>none of the default
 implementations of the methods of this abstract base class is
 thread-safe</i>.  If thread-safe guarantees are desired, the
 methods of this class should be overridden.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><CODE>preProcess(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><CODE>postProcess(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A>, 
<A HREF="../../../serialized-form.html#danbikel.parser.lang.AbstractTraining">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInfo">addGapInfo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caches the boolean value of the property <A HREF="../../../danbikel/parser/Settings.html#addGapInfo"><CODE>Settings.addGapInfo</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations">argAugmentations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A list representing the set of all argument augmentations.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html" title="class or interface in java.util">Map</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts">argContexts</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data member used to store the map required by the default implementation
 of the method <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContextsSym">argContextsSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol to indicate the list of argument-finding rules from a metadata
 resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals">argNonterminals</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static set for storing argument nonterminals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#baseNP">baseNP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The value of <A HREF="../../../danbikel/parser/Treebank.html#baseNPLabel()"><CODE>Treebank.baseNPLabel()</CODE></A>, cached for efficiency and
 convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym">canonicalAugDelimSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Symbol created from the first character of <A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>Treebank.augmentationDelimiters()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation">defaultArgAugmentation</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that will be used to identify argument nonterminals.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr">delimAndGapStr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The string consisting of the canonical augmentation delimiter
 concatenated with the gap augmentation, to be used in
 identifying nonterminals that contain gap augmentations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStrLen">delimAndGapStrLen</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The length of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><CODE>delimAndGapStr</CODE></A>, cached here for efficiency
 and convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation">gapAugmentation</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headFinder">headFinder</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Holds the value of <A HREF="../../../danbikel/parser/Language.html#headFinder()"><CODE>Language.headFinder()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headPostSym">headPostSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the right side of the head as an argument.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headPreSym">headPreSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the left side of the head as an argument.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headSym">headSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is a possible mapping in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the head as an argument.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#metadataPropertyPrefix">metadataPropertyPrefix</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The prefix of the property of the metadata resource required by the
 default constructor of concrete subclasses.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">nodesToPrune</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data member to store the set of nodes to prune for the default
 implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPruneSym">nodesToPruneSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol to indicate the list of nodes to prune.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#NP">NP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The value of <A HREF="../../../danbikel/parser/Treebank.html#NPLabel()"><CODE>Treebank.NPLabel()</CODE></A>, cached for efficiency and
 convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prunedPreterms">prunedPreterms</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The set of preterminals (<code>Sexp</code> objects) that have been pruned
 away.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prunedPunctuation">prunedPunctuation</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The set of preterminals (<code>Sexp</code> objects) that were "raised
 away" by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A> because they appeared either at
 the beginning or the end of a sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelHeadChildrenAsArgs">relabelHeadChildrenAsArgs</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates to relabel head children as arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs">repairBaseNPs</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caches the boolean value of the property
 <A HREF="../../../danbikel/parser/Settings.html#collinsRepairBaseNPs"><CODE>Settings.collinsRepairBaseNPs</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopListSym">semTagArgStopListSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol to indicate the list of node augmentations that prevent
 a node from being relabeled</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet">semTagArgStopSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data member used to store the set required by the method <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#traceTag">traceTag</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that gets assigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#treebank">treebank</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Holds the value of <A HREF="../../../danbikel/parser/Language.html#treebank()"><CODE>Language.treebank()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#wordsToPrune">wordsToPrune</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data member to store the set of words to prune for the default
 implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A>.  </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#AbstractTraining()">AbstractTraining</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default constructor for this abstract base class; sets <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to a new <code>Map</code> object, sets <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><CODE>semTagArgStopSet</CODE></A> to a new <code>Set</code> object and initializes <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym"><CODE>canonicalAugDelimSym</CODE></A>.  </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">addArgAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the default argument augmentation to the specified nonterminal
 if the specified label is not already an argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals()">argNonterminals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a static set of possible argument nonterminals.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#canonicalizeNonterminals(danbikel.lisp.Sexp)">canonicalizeNonterminals</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies each nonterminal in the specified tree to be its canonical
 version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#collectPreterms(java.util.Set, danbikel.lisp.Sexp)">collectPreterms</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A>&nbsp;preterms,
                <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds all preterminal subtrees to the specified set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()">createArgAugmentationsList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A helper method that runs through every nonterminal "pattern" for each
 context in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A>, parses the pattern using <A HREF="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>Treebank.parseNonterminal(danbikel.lisp.Symbol)</CODE></A>, runs through the resulting list of
 augmentations and adds each augmentation symbol to the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><CODE>argAugmentations</CODE></A> list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgNonterminalsSet()">createArgNonterminalsSet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><CODE>argNonterminals</CODE></A> data member to be the static set
 of argument nonterminals.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation()">defaultArgAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is used to mark argument (required) nonterminals by
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation()">gapAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol)">getCanonicalArg</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical version of the specified argument nonterminal. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">getCanonicalArg</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical version of the specified argument nonterminal. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPreterms()">getPrunedPreterms</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of pruned preterminals (<code>Sexp</code> objects).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPunctuation()">getPrunedPunctuation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)">hasGap</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
       <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;root,
       <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/ArrayList.html" title="class or interface in java.util">ArrayList</A>&nbsp;indexStack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns -1 if <code>tree</code> has no gap (trace), or the index of the
 trace otherwise.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Symbol)">hasGap</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasPossessiveChild(danbikel.lisp.Sexp)">hasPossessiveChild</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> contains a child for which
 <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A> returns
 <code>true</code>, <code>false</code> otherwise.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headPostSym()">headPostSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate to
 choose a child relative to the right side of the head as an argument. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headPreSym()">headPreSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the left side of the head as an argument.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#headSym()">headSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol used in the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> map to identify
 an offset from the head child.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isAllNodesToPrune(danbikel.lisp.Sexp)">isAllNodesToPrune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether all words or preterminals of this tree are to be pruned.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)">isArgument</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">isArgument</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
           <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)">isArgument</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
           <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
           boolean&nbsp;parseLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)">isArgumentFast</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isCoordinatedPhrase(danbikel.lisp.Sexp, int)">isCoordinatedPhrase</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                    int&nbsp;headIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if a non-head child of the specified
 tree is a conjunction, and that conjunction is either post-head
 but non-final, or immediately pre-head but non-initial (where
 &quot;immediately pre-head&quot; means &quot;at the first index
 less than <code>headIdx</code> that is not punctuation, as determined
 by <A HREF="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)"><CODE>Treebank.isPunctuation(Symbol)</CODE></A>).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isTypeOfSentence(danbikel.lisp.Symbol)">isTypeOfSentence</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A helper method used by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)"><CODE>repairBaseNPs(Sexp,int,Sexp)</CODE></A>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>tree</code> is a preterminal (the base
 case) or is a list with the first element of type <code>Symbol</code> (the
 node label) and subsequent elements are valid trees (the recursive case).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#main(java.lang.String[])">main</A></B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test driver for this class.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#needToAddNormalNPLevel(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">needToAddNormalNPLevel</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
                       int&nbsp;parentIdx,
                       <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if a unary NP needs to be added above the
 specified base NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)">preprocessing</A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)">preProcessTest</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
               <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalWords,
               <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preprocesses the specified test sentence and its coordinated list of tags.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#printMetadata()">printMetadata</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging method to print the metadata used by this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#readMetadata(danbikel.lisp.SexpTokenizer)">readMetadata</A></B>(<A HREF="../../../danbikel/lisp/SexpTokenizer.html" title="class in danbikel.lisp">SexpTokenizer</A>&nbsp;metadataTok)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads metadata to fill in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> and
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><CODE>semTagArgStopSet</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#readMetadataHook(danbikel.lisp.Symbol, int, danbikel.lisp.SexpList)">readMetadataHook</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;dataType,
                 int&nbsp;metadataLen,
                 <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;metadata)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A hook for subclasses to have their own custom metadata types.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelArgChildren(danbikel.lisp.SexpList, int, danbikel.lisp.SexpList)">relabelArgChildren</A></B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;treeList,
                   int&nbsp;headIdx,
                   <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;candidatePatterns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels as arguments all immediately-dominated children in the specified
 subtree accoding to the specified argument-finding patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeArgAugmentation(danbikel.lisp.Symbol)">removeArgAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes any argument augmentations from the specified nonterminal label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">removeArgAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                      <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses label into the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object and then
 removes all argument augmentations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeOnlyChildBaseNPs(danbikel.lisp.Sexp)">removeOnlyChildBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle case where an NP dominates a base NP and has no other children
 (the base NP is an "only child" of the dominating NP).  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)">removeWord</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word,
           <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag,
           int&nbsp;idx,
           <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
           <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags,
           <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalTags,
           <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A>&nbsp;prunedPretermsPosSet,
           <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html" title="class or interface in java.util">Map</A>&nbsp;prunedPretermsPosMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoked by the <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</A> as the first
 step in preprocessing (prior to the invocation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><CODE>preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</CODE></A>).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
              int&nbsp;parentIdx,
              <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)">setUpFastArgMap</A></B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#skip(danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is to be skipped when training.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#startSym()">startSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#startWord()">startWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#staticSetUpFastArgMap(danbikel.parser.CountsTable)">staticSetUpFastArgMap</A></B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stopSym()">stopSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stopWord()">stopWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Symbol)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the specified nonterminal label and removes all augmentations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)">stripAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   boolean&nbsp;parseLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills in the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object with the specified
 nonterminal label but without any augmentations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)">threadNPArgAugmentations</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#topSym()">topSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate the hidden root of all parse trees.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#topWord()">topWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#traceTag()">traceTag</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#transformSubjectNTs(danbikel.lisp.Sexp)">transformSubjectNTs</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#unaryProductionsToNull(danbikel.lisp.Sexp)">unaryProductionsToNull</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified subtree consists solely of unary productions
 going to a null element terminal.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="relabelHeadChildrenAsArgs"><!-- --></A><H3>
relabelHeadChildrenAsArgs</H3>
<PRE>
protected static final boolean <B>relabelHeadChildrenAsArgs</B></PRE>
<DL>
<DD>Indicates to relabel head children as arguments.  Such relabeling is
 unnecessary, since head children are already inherently distinct.  This
 flag should be true when emulating the behavior of Mike Collins' parser.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="addGapInfo"><!-- --></A><H3>
addGapInfo</H3>
<PRE>
protected static final boolean <B>addGapInfo</B></PRE>
<DL>
<DD>Caches the boolean value of the property <A HREF="../../../danbikel/parser/Settings.html#addGapInfo"><CODE>Settings.addGapInfo</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="repairBaseNPs"><!-- --></A><H3>
repairBaseNPs</H3>
<PRE>
protected static final boolean <B>repairBaseNPs</B></PRE>
<DL>
<DD>Caches the boolean value of the property
 <A HREF="../../../danbikel/parser/Settings.html#collinsRepairBaseNPs"><CODE>Settings.collinsRepairBaseNPs</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="argNonterminals"><!-- --></A><H3>
argNonterminals</H3>
<PRE>
protected static <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>argNonterminals</B></PRE>
<DL>
<DD>Static set for storing argument nonterminals.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="argContextsSym"><!-- --></A><H3>
argContextsSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>argContextsSym</B></PRE>
<DL>
<DD>The symbol to indicate the list of argument-finding rules from a metadata
 resource.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="semTagArgStopListSym"><!-- --></A><H3>
semTagArgStopListSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>semTagArgStopListSym</B></PRE>
<DL>
<DD>The symbol to indicate the list of node augmentations that prevent
 a node from being relabeled
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nodesToPruneSym"><!-- --></A><H3>
nodesToPruneSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>nodesToPruneSym</B></PRE>
<DL>
<DD>The symbol to indicate the list of nodes to prune.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><CODE>nodesToPrune</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DL>
<HR>

<A NAME="metadataPropertyPrefix"><!-- --></A><H3>
metadataPropertyPrefix</H3>
<PRE>
protected static final <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A> <B>metadataPropertyPrefix</B></PRE>
<DL>
<DD>The prefix of the property of the metadata resource required by the
 default constructor of concrete subclasses.  The value of this constant
 is <code>&quot;parser.training.metadata.&quot;</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#danbikel.parser.lang.AbstractTraining.metadataPropertyPrefix">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="treebank"><!-- --></A><H3>
treebank</H3>
<PRE>
protected <A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A> <B>treebank</B></PRE>
<DL>
<DD>Holds the value of <A HREF="../../../danbikel/parser/Language.html#treebank()"><CODE>Language.treebank()</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="headFinder"><!-- --></A><H3>
headFinder</H3>
<PRE>
protected <A HREF="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</A> <B>headFinder</B></PRE>
<DL>
<DD>Holds the value of <A HREF="../../../danbikel/parser/Language.html#headFinder()"><CODE>Language.headFinder()</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="gapAugmentation"><!-- --></A><H3>
gapAugmentation</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>gapAugmentation</B></PRE>
<DL>
<DD>The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  This method is used by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A>, so that gap augmentations that are added by
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> do not get removed.  The default value is
 the symbol returned by <code>Symbol.add(&quot;g&quot;)</code>.  If this
 default value conflicts with an augmentation already used in a particular
 Treebank, this value should be reassigned in the constructor of a
 subclass.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="delimAndGapStr"><!-- --></A><H3>
delimAndGapStr</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A> <B>delimAndGapStr</B></PRE>
<DL>
<DD>The string consisting of the canonical augmentation delimiter
 concatenated with the gap augmentation, to be used in
 identifying nonterminals that contain gap augmentations.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><CODE>Treebank.canonicalAugDelimiter()</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><CODE>gapAugmentation</CODE></A></DL>
</DL>
<HR>

<A NAME="delimAndGapStrLen"><!-- --></A><H3>
delimAndGapStrLen</H3>
<PRE>
protected int <B>delimAndGapStrLen</B></PRE>
<DL>
<DD>The length of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><CODE>delimAndGapStr</CODE></A>, cached here for efficiency
 and convenience.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultArgAugmentation"><!-- --></A><H3>
defaultArgAugmentation</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>defaultArgAugmentation</B></PRE>
<DL>
<DD>The symbol that will be used to identify argument nonterminals.  This
 method is used by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A>, so that argument
 augmentations that are added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A> do not
 get removed.  The default value is the symbol returned by
 <code>Symbol.add(&quot;A&quot;)</code>.  If this default value conflicts
 with an augmentation already used in a particular Treebank, this value
 should be reassigned in the constructor of a subclass.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="argAugmentations"><!-- --></A><H3>
argAugmentations</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A> <B>argAugmentations</B></PRE>
<DL>
<DD>A list representing the set of all argument augmentations.  By default,
 this data member will be initialized to a new list containing only the
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation">default argument augmentation</A>.
 Subclasses should add additional augmentations to this list in their
 constructors, or by invoking the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><CODE>createArgAugmentationsList()</CODE></A>
 method after filling in the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> map.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><CODE>createArgAugmentationsList()</CODE></A></DL>
</DL>
<HR>

<A NAME="traceTag"><!-- --></A><H3>
traceTag</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>traceTag</B></PRE>
<DL>
<DD>The symbol that gets assigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.  The default value is the return value of
 <code>Symbol.add(&quot;*TRACE*&quot;)</code>.  If this maps to an actual
 part of speech tag or nonterminal label in a particular Treebank, this
 data member should be reassigned in the constructor of a subclass.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="canonicalAugDelimSym"><!-- --></A><H3>
canonicalAugDelimSym</H3>
<PRE>
protected final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>canonicalAugDelimSym</B></PRE>
<DL>
<DD>A Symbol created from the first character of <A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>Treebank.augmentationDelimiters()</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nodesToPrune"><!-- --></A><H3>
nodesToPrune</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>nodesToPrune</B></PRE>
<DL>
<DD>Data member to store the set of nodes to prune for the default
 implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A>.  The set should only contain
 objects of type <code>Symbol</code>, and the elements of this set
 should be added in the constructor of a subclass.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DL>
<HR>

<A NAME="wordsToPrune"><!-- --></A><H3>
wordsToPrune</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>wordsToPrune</B></PRE>
<DL>
<DD>Data member to store the set of words to prune for the default
 implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A>.  The set should only contain
 objects of type <code>Symbol</code>, and the elements of this set should be
 added in the constructor of a subclass.  The default implementation will
 only prune a preterminal if both the part-of-speech tag is in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><CODE>nodesToPrune</CODE></A> <i><b>and</b></i> if the word is in this
 <code>wordsToPrune</code> set.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DL>
<HR>

<A NAME="prunedPreterms"><!-- --></A><H3>
prunedPreterms</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>prunedPreterms</B></PRE>
<DL>
<DD>The set of preterminals (<code>Sexp</code> objects) that have been pruned
 away.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="argContexts"><!-- --></A><H3>
argContexts</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html" title="class or interface in java.util">Map</A> <B>argContexts</B></PRE>
<DL>
<DD>Data member used to store the map required by the default implementation
 of the method <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.  This data member maps
 parent nonterminals to lists of children nonterminals, to indicate that
 the children are candidates for being labeled as arguments in the presence
 of that parent.  A children list may also be a list of the form
 <pre>
 (head &lt;offset&gt;)
 </pre>
 indicating to match a node <code>&lt;offset&gt;</code> away from the head
 child of the parent that was mapped to this children list.  The keys and
 values of this map should be added in the constructor of a subclass.
 The keys of this map must be of type <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp"><CODE>Symbol</CODE></A>, and the values of
 this map must be of type <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp"><CODE>SexpList</CODE></A>.
 <p>
 Optionally, after this data member has been filled in by the constructor
 of a subclass, the method <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><CODE>createArgAugmentationsList()</CODE></A> should
 be invoked to automatically fill in the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><CODE>argAugmentations</CODE></A> list.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><CODE>argAugmentations</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><CODE>createArgAugmentationsList()</CODE></A></DL>
</DL>
<HR>

<A NAME="semTagArgStopSet"><!-- --></A><H3>
semTagArgStopSet</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>semTagArgStopSet</B></PRE>
<DL>
<DD>Data member used to store the set required by the method <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.  The set contains semantic tags (which is
 English Treebank parlance) that prohibit a candidate argument child from
 being relabeled as an argument.  The objects in this set must all be of
 type <code>Symbol</code>.  The members of this set should be added in the
 constructor of a subclass.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A></DL>
</DL>
<HR>

<A NAME="headSym"><!-- --></A><H3>
headSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headSym</B></PRE>
<DL>
<DD>The symbol that is a possible mapping in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the head as an argument.  For example, an
 argument context might be <code>PP</code> mapping to <code>(head
 1))</code>, meaning that the child that is 1 position to the right of the
 head child of a PP should be relabeled as an argument.  The value of this
 data member is the symbol returned by
 <code>Symbol.add(&quot;head&quot;)</code>.  In the unlikely event that
 this value conflicts with a nonterminal in a particular Treebank, this
 data member should be reassigned in the constructor of a subclass.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A></DL>
</DL>
<HR>

<A NAME="headPreSym"><!-- --></A><H3>
headPreSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headPreSym</B></PRE>
<DL>
<DD>The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the left side of the head as an argument.
 For example, an argument context might be <code>VP</code> mapping to
 <code>(head-left left MD VBD)</code>, meaning that the children to the left
 of the head child should be searched from left to right, and the first
 child found that is a member of the set <tt>{MD, VBD}</tt> should be
 considered a possible argument of the head.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="headPostSym"><!-- --></A><H3>
headPostSym</H3>
<PRE>
protected static final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headPostSym</B></PRE>
<DL>
<DD>The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the right side of the head as an argument.
 For example, an argument context might be <code>PP</code> mapping to
 <code>(head-right left PP NP WHNP ADJP)</code>, meaning that the children
 to the right of the head child should be searched from left to right, and
 the first child found that is a member of the set
 <tt>{PP, NP, WHNP, ADJP}</tt> should be considered a possible argument
 of the head.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="baseNP"><!-- --></A><H3>
baseNP</H3>
<PRE>
protected final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>baseNP</B></PRE>
<DL>
<DD>The value of <A HREF="../../../danbikel/parser/Treebank.html#baseNPLabel()"><CODE>Treebank.baseNPLabel()</CODE></A>, cached for efficiency and
 convenience.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NP"><!-- --></A><H3>
NP</H3>
<PRE>
protected final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>NP</B></PRE>
<DL>
<DD>The value of <A HREF="../../../danbikel/parser/Treebank.html#NPLabel()"><CODE>Treebank.NPLabel()</CODE></A>, cached for efficiency and
 convenience.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="prunedPunctuation"><!-- --></A><H3>
prunedPunctuation</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>prunedPunctuation</B></PRE>
<DL>
<DD>The set of preterminals (<code>Sexp</code> objects) that were "raised
 away" by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A> because they appeared either at
 the beginning or the end of a sentence.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="AbstractTraining()"><!-- --></A><H3>
AbstractTraining</H3>
<PRE>
protected <B>AbstractTraining</B>()</PRE>
<DL>
<DD>Default constructor for this abstract base class; sets <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to a new <code>Map</code> object, sets <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><CODE>semTagArgStopSet</CODE></A> to a new <code>Set</code> object and initializes <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym"><CODE>canonicalAugDelimSym</CODE></A>.  Subclass constructors are responsible for filling
 in the data for <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> and <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><CODE>semTagArgStopSet</CODE></A>.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setUpFastArgMap(danbikel.parser.CountsTable)"><!-- --></A><H3>
setUpFastArgMap</H3>
<PRE>
public void <B>setUpFastArgMap</B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></B></DD>
<DD>Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 <p>
 <b>N.B.</b>: This method is necessarily thread-safe, as it is expected
 to be invoked by every <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> as it starts up, and since there
 can be multiple <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> instances within a given VM.
 <b><i>However</i></b>, note that it is <b>inappropriate to invoke this
 method</b> if the set of nonterminals in the specified counts table
 is incomplete (see the documentation for the <A HREF="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><CODE>SubcatBag</CODE></A> class
 for an instance where this will be the case).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#setUpFastArgMap(danbikel.parser.CountsTable)">setUpFastArgMap</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminals</CODE> - a counts table whose keys form a complete set of
 all possible nonterminal labels, as is obtained from
 <A HREF="../../../danbikel/parser/DecoderServerRemote.html#nonterminals()"><CODE>DecoderServerRemote.nonterminals()</CODE></A> (the counts to which the
 nonterminals are mapped are not used by this method)</DL>
</DD>
</DL>
<HR>

<A NAME="staticSetUpFastArgMap(danbikel.parser.CountsTable)"><!-- --></A><H3>
staticSetUpFastArgMap</H3>
<PRE>
protected static void <B>staticSetUpFastArgMap</B>(<A HREF="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</PRE>
<DL>
<DD>Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 <p>
 <b>N.B.</b>: This method is necessarily thread-safe, as it is expected
 to be invoked by every <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> as it starts up, and since there
 can be multiple <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> instances within a given VM.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminals</CODE> - a counts table whose keys form a complete set of
 all possible nonterminal labels, as is obtained from
 <A HREF="../../../danbikel/parser/DecoderServerRemote.html#nonterminals()"><CODE>DecoderServerRemote.nonterminals()</CODE></A> (the counts to which the
 nonterminals are mapped are not used by this method)</DL>
</DD>
</DL>
<HR>

<A NAME="preProcess(danbikel.lisp.Sexp)"><!-- --></A><H3>
preProcess</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>preProcess</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>The method to call before counting events in a training parse tree.
 This default implementation executes the following methods of this class
 in order:
 <ol>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>addBaseNPs(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><CODE>repairBaseNPs(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><CODE>removeNullElements(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>
 <li> <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A>
 </ol>
 While every attempt has been made to make the default implementations of
 these preprocessing methods independent of one another, the order above is
 not entirely arbitrary.  In particular:
 <ul>
 <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> should be run after methods that
 introduce new nodes, which in this case is <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>addBaseNPs(Sexp)</CODE></A>, as
 these new nodes may need to be used to thread the gap feature
 <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A> should be run after
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> because only those sentences whose
 empty subjects are <i>not</i> the result of WH-movement should be
 relabeled
 <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><CODE>removeNullElements(Sexp)</CODE></A> should be run after any
 methods that depend on the presence of null elements, such as
   <ul>
   <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A> because a sentence cannot
   be determined to be subjectless unless a null element is present as
   a child of a subject-marked node
   <br>and<br>
   <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> because the determination of
   the location of a trace requires the presence of indexed null elements
   </ul>
 <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A> should be run after
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><CODE>removeNullElements(Sexp)</CODE></A> because a null element that is a
 leftmost or rightmost child can block detection of a punctuation element
 that needs to be raised after removal of the null element (if a punctuation
 element is the next-to-leftmost or next-to-rightmost child of an interior
 node)
 <li><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A> should be run after all methods
 that may depend upon the presence of nonterminal augmentations: <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>, <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A> and
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>
 </ul>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to pre-process
<DT><B>Returns:</B><DD><code>tree</code> having been pre-processed</DL>
</DD>
</DL>
<HR>

<A NAME="removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)"><!-- --></A><H3>
removeWord</H3>
<PRE>
public boolean <B>removeWord</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word,
                          <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag,
                          int&nbsp;idx,
                          <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                          <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags,
                          <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalTags,
                          <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A>&nbsp;prunedPretermsPosSet,
                          <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html" title="class or interface in java.util">Map</A>&nbsp;prunedPretermsPosMap)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></B></DD>
<DD>Invoked by the <A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</A> as the first
 step in preprocessing (prior to the invocation of <A HREF="../../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><CODE>Training.preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</CODE></A>).
 Returns whether the specified word should be removed from the sentence
 before parsing.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)">removeWord</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - a word in the sentence about to parsed<DD><CODE>tag</CODE> - the supplied part-of-speech tag of the specified word,
 or <tt>null</tt> if tags were not supplied<DD><CODE>idx</CODE> - the index of the specified word in the specified sentence<DD><CODE>sentence</CODE> - a list of <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp"><CODE>Symbol</CODE></A> objects that represent the words
 of the sentence to be parsed<DD><CODE>tags</CODE> - coordinated list of supplied part-of-speech tag lists for each
 of the words in the specified sentence, or <tt>null</tt> if no tags
 were supplied<DD><CODE>originalTags</CODE> - the cached copy of the specified <tt>tags</tt> list,
 used when <A HREF="../../../danbikel/parser/Settings.html#restorePrunedWords"><CODE>Settings.restorePrunedWords</CODE></A> is <tt>true</tt><DD><CODE>prunedPretermsPosSet</CODE> - the set of part-of-speech tags that were
 pruned during training<DD><CODE>prunedPretermsPosMap</CODE> - a map of words pruned during training to
 their part-of-speech tags when they were pruned
<DT><B>Returns:</B><DD>whether the specified word should be removed from the sentence
 before parsing</DL>
</DD>
</DL>
<HR>

<A NAME="preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><!-- --></A><H3>
preProcessTest</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A> <B>preProcessTest</B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                               <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalWords,
                               <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags)</PRE>
<DL>
<DD>Preprocesses the specified test sentence and its coordinated list of tags.
 The default implementation here does nothing.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)">preProcessTest</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sentence</CODE> - the list of words, where a known word is a symbol and
 an unknown word is represented by a 3-element list (see
 <A HREF="../../../danbikel/parser/DecoderServerRemote.html#convertUnknownWords(danbikel.lisp.SexpList)"><CODE>DecoderServerRemote.convertUnknownWords(danbikel.lisp.SexpList)</CODE></A>)<DD><CODE>originalWords</CODE> - the list of unprocessed words (all symbols)<DD><CODE>tags</CODE> - the list of tag lists, where the list at index <i>i</i>
 is the list of possible parts of speech for the word at that index
<DT><B>Returns:</B><DD>a two-element list, containing two lists, the first of which
 is a processed version of <code>sentence</code> and the second of which
 is a processed version of <code>tags</code>; if <code>tags</code>
 is <code>null</code>, then the returned list will contain only
 one element (since <code>SexpList</code> objects are not designed
 to handle null elements)</DL>
</DD>
</DL>
<HR>

<A NAME="isValidTree(danbikel.lisp.Sexp)"><!-- --></A><H3>
isValidTree</H3>
<PRE>
public boolean <B>isValidTree</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if <code>tree</code> is a preterminal (the base
 case) or is a list with the first element of type <code>Symbol</code> (the
 node label) and subsequent elements are valid trees (the recursive case).
 If a language package requires a different definition of training parse
 tree validity, this method should be overridden.  However, changing the
 definition of tree validity should be done with care, as the default
 implementations of the tree-processing methods in this class require trees
 that correspond to the definition of validity implemented by this method.
 This method also ensures that not all words or preterminals in the tree
 are to be pruned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to check for validity<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isAllNodesToPrune(danbikel.lisp.Sexp)"><CODE>isAllNodesToPrune(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPreterminal(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAllNodesToPrune(danbikel.lisp.Sexp)"><!-- --></A><H3>
isAllNodesToPrune</H3>
<PRE>
public boolean <B>isAllNodesToPrune</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether all words or preterminals of this tree are to be pruned.
 For example, if the part-of-speech tag "." is a <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">node to prune</A> and the word "rubbish" is a <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#wordsToPrune">word to prune</A> and the specified tree is <tt>(S (NN rubbish) (. .))</tt>
 then this method will return <tt>true</tt>.  If <tt>S</tt>
 is a <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">node to prune</A>, then this method
 will return <tt>true</tt> for the tree <tt>(S (NN rubbish) (. .))</tt>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree to inspect
<DT><B>Returns:</B><DD>whether all nodes of this tree are to be pruned.<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="skip(danbikel.lisp.Sexp)"><!-- --></A><H3>
skip</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A> <B>skip</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether the specified tree is to be skipped when training.
 The default implementation here simply returns the negation of the
 return value of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isValidTree(danbikel.lisp.Sexp)"><CODE>isValidTree(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#skip(danbikel.lisp.Sexp)">skip</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - an annotated training tree
<DT><B>Returns:</B><DD>a string if the specified tree is to be skipped
 when training, <code>null</code> otherwise<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Trainer.html#train(danbikel.lisp.SexpTokenizer, boolean, boolean)"><CODE>Trainer.train(SexpTokenizer,boolean,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="transformSubjectNTs(danbikel.lisp.Sexp)"><!-- --></A><H3>
transformSubjectNTs</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>transformSubjectNTs</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.  For example, transforms <tt>NP-SBJ-1</tt>
 to <tt>NP-SBJ</tt>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree in which to transform subject nonterminals
<DT><B>Returns:</B><DD>the specified tree but with subject nonterminals transformed
 to remove separators between their base labels and their subject
 augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="getPrunedPreterms()"><!-- --></A><H3>
getPrunedPreterms</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>getPrunedPreterms</B>()</PRE>
<DL>
<DD>Returns the set of pruned preterminals (<code>Sexp</code> objects).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#getPrunedPreterms()">getPrunedPreterms</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prune(danbikel.lisp.Sexp)"><!-- --></A><H3>
prune</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>prune</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 <p>
 <b>Side effect</b>: An internal set of pruned preterminals will
 be updated.  This set may be accessed via <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPreterms()"><CODE>getPrunedPreterms()</CODE></A>.
 <p>
 <b>Bugs</b>: Cannot prune away entire tree if the root label of the
 specified tree is in <code>nodesToPrune</code>.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)">prune</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to prune
<DT><B>Returns:</B><DD><code>tree</code> having been pruned<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><CODE>nodesToPrune</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="collectPreterms(java.util.Set, danbikel.lisp.Sexp)"><!-- --></A><H3>
collectPreterms</H3>
<PRE>
protected final void <B>collectPreterms</B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A>&nbsp;preterms,
                                     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Adds all preterminal subtrees to the specified set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterms</CODE> - the set to which preterminal subtrees of the specified
 tree are to be added<DD><CODE>tree</CODE> - the tree from which to collect preterminal subtrees</DL>
</DD>
</DL>
<HR>

<A NAME="identifyArguments(danbikel.lisp.Sexp)"><!-- --></A><H3>
identifyArguments</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>identifyArguments</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Augments labels of nonterminals that are arguments.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if argument identification is not desired for a particular
 language package.
 <p>
 Note that children in a coordinated phrase are never relabeled as
 arguments, as determined by subtrees for which
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isCoordinatedPhrase(danbikel.lisp.Sexp, int)"><CODE>isCoordinatedPhrase(Sexp,int)</CODE></A> returns <code>true</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to modify
<DT><B>Returns:</B><DD>a reference to the modified <code>tree</code> object<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><CODE>Treebank.canonicalAugDelimiter()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="relabelArgChildren(danbikel.lisp.SexpList, int, danbikel.lisp.SexpList)"><!-- --></A><H3>
relabelArgChildren</H3>
<PRE>
protected void <B>relabelArgChildren</B>(<A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;treeList,
                                  int&nbsp;headIdx,
                                  <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;candidatePatterns)</PRE>
<DL>
<DD>Relabels as arguments all immediately-dominated children in the specified
 subtree accoding to the specified argument-finding patterns.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>treeList</CODE> - the subtree in which to relabel arguments<DD><CODE>headIdx</CODE> - the index of the child of the specified subtree
                          that is the head<DD><CODE>candidatePatterns</CODE> - the set of argument-finding rules</DL>
</DD>
</DL>
<HR>

<A NAME="addArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
addArgAugmentation</H3>
<PRE>
protected boolean <B>addArgAugmentation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                     <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Adds the default argument augmentation to the specified nonterminal
 if the specified label is not already an argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label that has been parsed into the specified
 <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object<DD><CODE>nonterminal</CODE> - the parsed version of the specified label
<DT><B>Returns:</B><DD><tt>true</tt> if the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object
 was modified, <tt>false</tt> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="defaultArgAugmentation()"><!-- --></A><H3>
defaultArgAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>defaultArgAugmentation</B>()</PRE>
<DL>
<DD>The symbol that is used to mark argument (required) nonterminals by
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#defaultArgAugmentation()">defaultArgAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalArg(danbikel.lisp.Symbol)"><!-- --></A><H3>
getCanonicalArg</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonicalArg</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns the canonical version of the specified argument nonterminal. The
 default implementation here takes the base of the (possibly compelx)
 nonterminal label and converts it via <A HREF="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><CODE>Treebank.getCanonical(Symbol)</CODE></A>.
 For example, in the English Penn Treebank, <tt>S</tt> nonterminals that
 dominate trees with no subjects get converted to <tt>SG</tt>; if one of
 these is identified as an argument, it will be converted to <tt>SG-A</tt>;
 this method will return <tt>S-A</tt>, since <tt>S</tt> is the canonical
 version of <tt>SG</tt>.  This method is needed by the class <A HREF="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><CODE>SubcatBag</CODE></A>.
 <br>
 <b>Implementation note</b>: This method uses an internal
 cache to perform argument label canonicalizations in O(1) expected time.
 For cache misses the actual canonicalization is handled by the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>getCanonicalArg(Symbol,Nonterminal)</CODE></A> method.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#getCanonicalArg(danbikel.lisp.Symbol)">getCanonicalArg</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the argument nonterminal label to be canonicalized
<DT><B>Returns:</B><DD>the canonical version of the sepcified argument label<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>getCanonicalArg(Symbol, Nonterminal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalArg(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
getCanonicalArg</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonicalArg</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                              <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Returns the canonical version of the specified argument nonterminal. The
 default implementation here takes the base of the (possibly compelx)
 nonterminal label and converts it via <A HREF="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><CODE>Treebank.getCanonical(Symbol)</CODE></A>.
  For example, in the English Penn Treebank, <tt>S</tt> nonterminals that
 dominate trees with no subjects get converted to <tt>SG</tt>; if one of
 these is identified as an argument, it will be converted to <tt>SG-A</tt>;
 this method will return <tt>S-A</tt>, since <tt>S</tt> is the canonical
 version of <tt>SG</tt>.  This method is needed by the class <A HREF="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><CODE>SubcatBag</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the argument nonterminal label whose canonical version is
 to be returned<DD><CODE>nonterminal</CODE> - the <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> instance to be used
<DT><B>Returns:</B><DD>the canonical version of the specified argument label</DL>
</DD>
</DL>
<HR>

<A NAME="isArgument(danbikel.lisp.Symbol)"><!-- --></A><H3>
isArgument</H3>
<PRE>
public boolean <B>isArgument</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#isArgument(danbikel.lisp.Symbol)">isArgument</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
isArgument</H3>
<PRE>
protected boolean <B>isArgument</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                             <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.  This method is a synonym for
 <tt>isArgument(label, nonterminal, true)</tt>.
 <br>
 <b>Implementation note</b>: This method is <i>not</i> thread-safe;
 for a thread-safe method, please use <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)"><CODE>isArgumentFast(Symbol)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be tested<DD><CODE>nonterminal</CODE> - the <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> instance to be used for
 storing the parsed version of the specified nonterminal label
<DT><B>Returns:</B><DD>whether the specified nonterminal label has an argument
 augmentation<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)"><CODE>isArgument(Symbol,Nonterminal,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)"><!-- --></A><H3>
isArgument</H3>
<PRE>
protected boolean <B>isArgument</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                             <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                             boolean&nbsp;parseLabel)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.
 <br>
 <b>Implementation note</b>: This method is <i>not</i> thread-safe;
 for a thread-safe method, please use <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)"><CODE>isArgumentFast(Symbol)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be tested<DD><CODE>nonterminal</CODE> - the <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> instance to be used for
 storing the parsed version of the specified nonterminal label<DD><CODE>parseLabel</CODE> - indicates whether to parse the specified label
 before checking whether it is an argument
<DT><B>Returns:</B><DD>whether the specified nonterminal label has an argument
 augmentation</DL>
</DD>
</DL>
<HR>

<A NAME="isArgumentFast(danbikel.lisp.Symbol)"><!-- --></A><H3>
isArgumentFast</H3>
<PRE>
public boolean <B>isArgumentFast</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.<br>
 <b>Implementation note</b>: Unlike <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><CODE>isArgument(Symbol)</CODE></A>, this
 method is thread-safe.  Also, after <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)"><CODE>setUpFastArgMap(CountsTable)</CODE></A>
 has been invoked, this method is much more efficient than
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><CODE>isArgument(Symbol)</CODE></A>, as it uses an internal cache for O(1)
 expected time operation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#isArgumentFast(danbikel.lisp.Symbol)">isArgumentFast</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)"><CODE>setUpFastArgMap(CountsTable)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addGapInformation(danbikel.lisp.Sexp)"><!-- --></A><H3>
addGapInformation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>addGapInformation</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  This method is
 optional, and may simply return <code>tree</code> untouched if gap
 information is desired for a particular language package.  The default
 implementation of this method checks the setting of the property <A HREF="../../../danbikel/parser/Settings.html#addGapInfo"><CODE>Settings.addGapInfo</CODE></A>: if this property is <code>false</code>, then
 <code>tree</code> is returned untouched; otherwise, this method simply
 calls <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)"><CODE>hasGap(Sexp,Sexp,ArrayList)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to which to add gapping
<DT><B>Returns:</B><DD>the same <code>tree</code> that was passed in, with certain
 nodes modified to include gap information<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)"><CODE>hasGap(Sexp, Sexp, ArrayList)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)"><!-- --></A><H3>
hasGap</H3>
<PRE>
protected int <B>hasGap</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                     <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;root,
                     <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/ArrayList.html" title="class or interface in java.util">ArrayList</A>&nbsp;indexStack)</PRE>
<DL>
<DD>Returns -1 if <code>tree</code> has no gap (trace), or the index of the
 trace otherwise.  If <code>tree</code> is a null preterminal with an
 indexed terminal (a trace) that matches the index at the top of
 <code>indexStack</code>, then that index is popped off the stack, the
 preterminal label is changed to be <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><CODE>traceTag</CODE></A>, and the index of the
 trace is returned.  If a child of <code>tree</code> has a gap but another
 child is a WHNP that is coindexed, then the gap is &quot;filled&quot;, and
 this method returns -1; otherwise, this method augments the label of
 <code>tree</code> with <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><CODE>gapAugmentation</CODE></A> and returns the gap index
 of the child.
 <p>
 Put informally, this method does a depth-first search of <code>tree</code>,
 pushing the indices of any indexed WHNP nodes onto <code>indexStack</code>
 and popping off those indices when the corresponding null element is found
 someplace deeper in the tree.  The stack is necessary to allow for
 the nesting of gaps in a tree.
 <p>
 <b>Algorithm</b>:
 <pre>
 <font color=red>// base case</font>
 <b>if</b> tree is a null-element preterminal with an index that matches top of
    indexStack
 <b>then</b>
   modify preterminal to be traceTag;
   <b>return</b> pop(indexStack);
 <b>endif</b>

 <b>int</b> numWHNPChildren = 0;
 <b>Sexp</b> whnpChild = <b>null</b>;
 <b>foreach</b> child <b>of</b> tree <b>do</b>
   <b>if</b> child is a WHNP with an index augmentation <b>then</b>
     <b>if</b> numWHNPChildren == 0 <b>then</b>
       whnpChild = child;
     <b>endif</b>
     numWHNPChildren++;
   <b>endif</b>
 <b>end</b>

 <b>if</b> numWHNPChildren &gt; 0 <b>then</b>
   push(index of whnpChild, indexStack);
 <b>endif</b>

 <b>int</b> numTracesToBeLinked = 0, traceIndex = -1;
 <b>foreach</b> child <b>of</b> tree <b>do</b>
   <b>int</b> gapIndex = hasGap(child, root, indexStack); <font color=red>// recursive call</font>
   <b>if</b> gapIndex != -1 <b>then</b>
     <b>if</b> numTracesToBeLinked == 0 <b>then</b>
       traceIndex = gapIndex;
     <b>endif</b>
     numTracesToBeLinked++;
   <b>endif</b>
 <b>end</b>

 <b>if</b> numTracesToBeLinked &gt; 0 <b>then</b>
   add gap augmentation to the current parent (the root of <b>tree</b>);
   <b>if</b> numWHNPChildren &gt; 0 <b>and</b> index of whnpChild == traceIndex <b>then</b>
     <font color=red>// a trace from a child subtree has been hooked up with the current WHNP child</font>
     <b>return</b> -1;
   <b>else</b>
     <b>return</b> traceIndex;
   <b>endif</b>
 <b>else</b>
   <b>if</b> numWHNPChildren &gt; 0 <b>then</b>
     <b>print</b> warning that a moved WHNP node doesn't have a coindexed trace
       in any of its parent's other child subtrees;
   <b>endif</b>
   <b>return</b> -1;
 <b>endif</b>
 </pre>
 A warning will also be issued if there are crossing WHNP-trace
 dependencies.
 <p>
 This method is called by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(danbikel.lisp.Sexp)</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree to gapify<DD><CODE>root</CODE> - always the root of the tree we're gapifying, for error and
 warning reporting<DD><CODE>indexStack</CODE> - a stack of <code>Integer</code> objects (where the top
 of the stack is the highest-indexed object), representing the pending
 requests to find traces to match with coindexed WHNP's discovered higher
 up in the tree (earlier in the DFS)
<DT><B>Returns:</B><DD>-1 if <code>tree</code> has no gap, or the index of the trace
 otherwise<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><CODE>gapAugmentation</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><CODE>traceTag</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#isWHNP(danbikel.lisp.Symbol)"><CODE>Treebank.isWHNP(Symbol)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)"><CODE>Treebank.getTraceIndex(Sexp, Nonterminal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasGap(danbikel.lisp.Symbol)"><!-- --></A><H3>
hasGap</H3>
<PRE>
public boolean <B>hasGap</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#hasGap(danbikel.lisp.Symbol)">hasGap</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gapAugmentation()"><!-- --></A><H3>
gapAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>gapAugmentation</B>()</PRE>
<DL>
<DD>The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  This method is used by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A>, so that gap augmentations that are added by
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> do not get removed.  The default value is
 the symbol returned by <code>Symbol.add(&quot;g&quot;)</code>.  If this
 default value conflicts with an augmentation already used in a particular
 Treebank, the value of the data member <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><CODE>gapAugmentation</CODE></A> should be
 reassigned in the constructor of a subclass.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#gapAugmentation()">gapAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="traceTag()"><!-- --></A><H3>
traceTag</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>traceTag</B>()</PRE>
<DL>
<DD>The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.  The default value is the return value of
 <code>Symbol.add(&quot;*TRACE*&quot;)</code>.  If this maps to an actual
 part of speech tag or nonterminal label in a particular Treebank, the
 data member <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><CODE>traceTag</CODE></A> should be reassigned in the constructor
 of a subclass.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#traceTag()">traceTag</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="relabelSubjectlessSentences(danbikel.lisp.Sexp)"><!-- --></A><H3>
relabelSubjectlessSentences</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>relabelSubjectlessSentences</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if subjectless sentence relabeling is not desired for a
 particular language package.
 <p>
 The default implementation here assumes that a subjectless sentence is a
 node for which <A HREF="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><CODE>Treebank.isSentence(Symbol)</CODE></A> returns
 <code>true</code> and has a child with an augmentation for which <A HREF="../../../danbikel/parser/Treebank.html#subjectAugmentation()"><CODE>Treebank.subjectAugmentation()</CODE></A> returns <code>true</code>, and that this
 child represents a subtree that is a series of unary productions, ending in
 a subtree for which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A>
 returns <code>true</code>.  Informally, this method looks for sentence
 nodes that have a child marked as a subject, where that child has a null
 element as its first (and presumably only) child.  For example, in the
 English Treebank, this would mean one of the following contexts:
 <pre>
 (S (PREMOD ...) (NP-SBJ (-NONE- *T*)) ... )
 </pre>
 or
 <pre>
 (S (PREMOD ...) (NP-SBJ (NPB (-NONE- *T*))) ... )
 </pre>
 where <tt>(PREMOD ...)</tt> represents zero or more premodifying phrases
 and where <tt>NPB</tt> represents a node inserted by a method such as
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>addBaseNPs(Sexp)</CODE></A>.  Note that the subtree rooted by <tt>NPB</tt>
 satisfies the condition of being a subtree that is the result of a
 series of unary productions (one of them, in this case) ending
 in a null element preterminal.  (This seemingly over-complicated condition
 is necessary for this method to run properly after <code>tree</code>
 has been processed by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>addBaseNPs(Sexp)</CODE></A>.)
 <p>
 If a subclass of this class in a language package requires more
 extensive or different checking for the &quot;subjectlessness&quot; of a
 sentence, this method should be overridden.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree in which to relabel subjectless sentences
<DT><B>Returns:</B><DD>the same <code>tree</code> that was passed in, with
 subjectless sentence nodes relabeled<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><CODE>Treebank.isSentence(Symbol)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#subjectAugmentation()"><CODE>Treebank.subjectAugmentation()</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unaryProductionsToNull(danbikel.lisp.Sexp)"><!-- --></A><H3>
unaryProductionsToNull</H3>
<PRE>
protected final boolean <B>unaryProductionsToNull</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether the specified subtree consists solely of unary productions
 going to a null element terminal.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the subtree to test
<DT><B>Returns:</B><DD>whether the specified subtree consists solely of unary productions
         going to a null element terminal.</DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentations(danbikel.lisp.Sexp)"><!-- --></A><H3>
stripAugmentations</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>stripAugmentations</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  The set of nonterminal labels does <i>not</i> include
 preterminals, which are typically parts of speech.  If a particular
 language's Treebank augments preterminals, this method should be
 overridden in a language package's subclass. The only augmentations that
 will not be removed are those that are added by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>, so as to preserve the transformations of that
 method.  This method should only be called subsequent to the invocations
 of methods that require augmentations, such as <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree all of the nonterminals of which are to be stripped
 of all augmentations except those added by <code>identifyArguments</code>
<DT><B>Returns:</B><DD>a reference to <code>tree</code></DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentations(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripAugmentations</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAugmentations</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Parses the specified nonterminal label and removes all augmentations.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label from which to strip all augmentations
<DT><B>Returns:</B><DD>the specified label having been stripped of augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentations(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)"><!-- --></A><H3>
stripAugmentations</H3>
<PRE>
protected void <B>stripAugmentations</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                  <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                                  boolean&nbsp;parseLabel)</PRE>
<DL>
<DD>Fills in the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object with the specified
 nonterminal label but without any augmentations.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label from which to strip augmentations<DD><CODE>nonterminal</CODE> - the <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object to use for
 storage when optionally parsing the specified label and removing
 all augmentations<DD><CODE>parseLabel</CODE> - indicates whether to call
 <A HREF="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>Treebank.parseNonterminal(Symbol)</CODE></A>; if <tt>false</tt>, this
 method assumes that the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object
 already contains the results of parsing the specified nonterminal
 label (if this is not the case, then the behavior of this method
 is undefined)</DL>
</DD>
</DL>
<HR>

<A NAME="raisePunctuation(danbikel.lisp.Sexp)"><!-- --></A><H3>
raisePunctuation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>raisePunctuation</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  One consequence is that all punctuation is removed from
 the beginning and end of the sentence.  The punctuation affected is
 defined by the implementation of the method <A HREF="../../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>Treebank.isPuncToRaise(Sexp)</CODE></A>.
 <p>
 <b>Side effect</b>: All preterminals removed from the beginning and end
 of the sentence are stored in an internal set, which can be accessed
 via <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPunctuation()"><CODE>getPrunedPunctuation()</CODE></A>.
 <p>
 Example of punctuation raising:
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old)
      (, ,))
    (VP joined (NP (NPB the board))) (. .))
 </pre>
 becomes
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old))
    (, ,)
    (VP joined (NP (NPB the board))))
 </pre>
 This method appropriately deals with the case of having multiple
 punctuation elements to be raised on the left or right side of the list of
 children for a nonterminal.  For example, in English, if this method
 were passed the tree
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky) (. .) (. .) (. .))
   (VP (VB was) (ADJP (JJ stupid)))
   (. .) (. .) (. .))
 </pre>
 the result would be
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky))
   (. .) (. .) (. .)
   (VP (VB was) (ADJP (JJ stupid))))
 </pre>
 <p>
 <b>Bugs</b>: In the pathological case where all the children of a node
 are punctuation to raise, this method simply emits a warning to
 <code>System.err</code> and does not attempt to raise them (which would
 cause an interior node to become a leaf).
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to destructively modify by raising punctuation
<DT><B>Returns:</B><DD>a reference to the modified <code>tree</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="getPrunedPunctuation()"><!-- --></A><H3>
getPrunedPunctuation</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>getPrunedPunctuation</B>()</PRE>
<DL>
<DD>Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#getPrunedPunctuation()">getPrunedPunctuation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addBaseNPs(danbikel.lisp.Sexp)"><!-- --></A><H3>
addBaseNPs</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>addBaseNPs</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A>.  If an NP
 is relabeled as a base NP but is not dominated by another NP, then
 a new NP is interposed, for the sake of consistency.  For example,
 if the specified tree is the English Treebank tree
 <pre>
 (S (NP-SBJ (DT The) (NN dog)) (VP (VBD sat)))
 </pre>
 then this method will transform it to be
 <pre>
 (S (NP-SBJ (NPB (DT The) (NN dog))) (VP (VBD sat)))
 </pre>
 Note that the <tt>SBJ</tt> augmentation is transferred to the
 enclosing NP.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree in which to add and/or relabel base NPs
<DT><B>Returns:</B><DD>a reference to the modified version of <code>tree</code><DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasPossessiveChild(danbikel.lisp.Sexp)"><CODE>hasPossessiveChild(Sexp)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)"><CODE>Treebank.isNP(Symbol)</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#baseNPLabel()"><CODE>Treebank.baseNPLabel()</CODE></A>, 
<A HREF="../../../danbikel/parser/Treebank.html#NPLabel()"><CODE>Treebank.NPLabel()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="repairBaseNPs(danbikel.lisp.Sexp)"><!-- --></A><H3>
repairBaseNPs</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>repairBaseNPs</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  That is, situations such as
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort)
     (S ...)))
 </pre>
 get transformed to
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort))
   (S ...))
 </pre>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree whose base NPs are to be repaired
<DT><B>Returns:</B><DD>a modified version of the specified tree</DL>
</DD>
</DL>
<HR>

<A NAME="repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)"><!-- --></A><H3>
repairBaseNPs</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>repairBaseNPs</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
                             int&nbsp;parentIdx,
                             <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  That is, situations such as
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort)
     (S ...)))
 </pre>
 get transformed to
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort))
   (S ...))
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>grandparent</CODE> - the grandparent of the specified tree, or
 <code>null</code> if the specified tree is the root<DD><CODE>parentIdx</CODE> - the index of the specified tree in the
 the specified grandparent's list of children<DD><CODE>tree</CODE> - the tree in which to repair base NPs</DL>
</DD>
</DL>
<HR>

<A NAME="threadNPArgAugmentations(danbikel.lisp.Sexp)"><!-- --></A><H3>
threadNPArgAugmentations</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>threadNPArgAugmentations</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isTypeOfSentence(danbikel.lisp.Symbol)"><!-- --></A><H3>
isTypeOfSentence</H3>
<PRE>
protected boolean <B>isTypeOfSentence</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>A helper method used by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)"><CODE>repairBaseNPs(Sexp,int,Sexp)</CODE></A>.
 While the default implementation here simply returns the result of
 calling <A HREF="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><CODE>Treebank.isSentence(Symbol)</CODE></A> with the specified label,
 subclasses may override this method if different semantics are required
 for identifying sentences that occur as siblings of base NPs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the nonterminal label to test
<DT><B>Returns:</B><DD><code>true</code> if the specified nonterminal represents a
 sentence, <code>false</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="needToAddNormalNPLevel(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)"><!-- --></A><H3>
needToAddNormalNPLevel</H3>
<PRE>
protected boolean <B>needToAddNormalNPLevel</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;grandparent,
                                         int&nbsp;parentIdx,
                                         <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if a unary NP needs to be added above the
 specified base NP.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>grandparent</CODE> - the parent of the &quot;parent&quot; that is a
 base NP<DD><CODE>parentIdx</CODE> - the index of the child of <code>grandparent</code>
 that is the base NP (that is,
 <pre>grandparent.list().get(parentIdx) == tree</pre><DD><CODE>tree</CODE> - the base NP, whose parent is <code>grandparent</code></DL>
</DD>
</DL>
<HR>

<A NAME="isCoordinatedPhrase(danbikel.lisp.Sexp, int)"><!-- --></A><H3>
isCoordinatedPhrase</H3>
<PRE>
protected boolean <B>isCoordinatedPhrase</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree,
                                      int&nbsp;headIdx)</PRE>
<DL>
<DD>Returns <code>true</code> if a non-head child of the specified
 tree is a conjunction, and that conjunction is either post-head
 but non-final, or immediately pre-head but non-initial (where
 &quot;immediately pre-head&quot; means &quot;at the first index
 less than <code>headIdx</code> that is not punctuation, as determined
 by <A HREF="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)"><CODE>Treebank.isPunctuation(Symbol)</CODE></A>).  A child is a
 conjunction if its label is one for which
 <A HREF="../../../danbikel/parser/Treebank.html#isConjunction(danbikel.lisp.Symbol)"><CODE>Treebank.isConjunction(Symbol)</CODE></A> returns <code>true</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the (sub)tree to test<DD><CODE>headIdx</CODE> - the index of the head child of the specified tree</DL>
</DD>
</DL>
<HR>

<A NAME="hasPossessiveChild(danbikel.lisp.Sexp)"><!-- --></A><H3>
hasPossessiveChild</H3>
<PRE>
protected boolean <B>hasPossessiveChild</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if <code>tree</code> contains a child for which
 <A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isPossessivePreterminal(Sexp)</CODE></A> returns
 <code>true</code>, <code>false</code> otherwise.  This is a helper method
 used by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>addBaseNPs(Sexp)</CODE></A>.
 Possessive children are often more even-tempered than possessive parents.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse subtree to check for possessive preterminal
 children</DL>
</DD>
</DL>
<HR>

<A NAME="removeNullElements(danbikel.lisp.Sexp)"><!-- --></A><H3>
removeNullElements</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeNullElements</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  Additionally, if the removal of a null element leaves
 an interior node that is childless, then this interior node is removed as
 well.  For example, if we have the following sentence in English
 <pre> (S (NP-SBJ (-NONE- *T*)) (VP ...)) </pre>
 it will be transformed to be
 <pre> (S (VP ...)) </pre>
 <b>N.B.</b>: This method should only be invoked <i>after</i> preprocessing
 with <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A> and <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>, as these methods (and possibly others, if
 overridden) rely on the presence of null elements.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="startSym()"><!-- --></A><H3>
startSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>startSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.  The default value is the return
 value of <code>Symbol.add(&quot;+START+&quot;)</code>; if this value
 conflicts with an actual nonterminal in a particular Treebank, then this
 method should be overridden.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#startSym()">startSym</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="startWord()"><!-- --></A><H3>
startWord</H3>
<PRE>
public <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>startWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#startWord()">startWord</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#startSym()"><CODE>startSym()</CODE></A>, 
<A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stopSym()"><!-- --></A><H3>
stopSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stopSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.  The default value is the return
 value of <code>Symbol.add(&quot;+STOP+&quot;)</code>; if this value
 conflicts with an actual nonterminal in a particular Treebank, then this
 method should be overridden.
 <p>
 This symbol may also be used as a special value that is guaranteed not
 to conflict with any nonterminal in a given language's treebank.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#stopSym()">stopSym</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stopWord()"><!-- --></A><H3>
stopWord</H3>
<PRE>
public <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>stopWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#stopWord()">stopWord</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTraining.html#stopSym()"><CODE>stopSym()</CODE></A>, 
<A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="topSym()"><!-- --></A><H3>
topSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>topSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate the hidden root of all parse trees.  The
 default value is the return value of
 <code>Symbol.add(&quot;+TOP+&quot;)</code>; if this value conflicts with
 an actual nonterminal in a particular Treebank, then this method should be
 overridden.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#topSym()">topSym</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="topWord()"><!-- --></A><H3>
topWord</H3>
<PRE>
public <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>topWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#topWord()">topWord</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="headSym()"><!-- --></A><H3>
headSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headSym</B>()</PRE>
<DL>
<DD>Returns the symbol used in the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> map to identify
 an offset from the head child.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="headPreSym()"><!-- --></A><H3>
headPreSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headPreSym</B>()</PRE>
<DL>
<DD>The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate
 to choose a child relative to the left side of the head as an argument.
 For example, an argument context might be <code>VP</code> mapping to
 <code>(head-left left MD VBD)</code>, meaning that the children to the left
 of the head child should be searched from left to right, and the first
 child found that is a member of the set <tt>{MD, VBD}</tt> should be
 considered a possible argument of the head.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="headPostSym()"><!-- --></A><H3>
headPostSym</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>headPostSym</B>()</PRE>
<DL>
<DD>The symbol that is a possible mapping <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> to indicate to
 choose a child relative to the right side of the head as an argument. For
 example, an argument context might be <code>PP</code> mapping to
 <code>(head-right left PP NP WHNP ADJP)</code>, meaning that the children
 to the right of the head child should be searched from left to right, and
 the first child found that is a member of the set <tt>{PP, NP, WHNP,
 ADJP}</tt> should be considered a possible argument of the head.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createArgAugmentationsList()"><!-- --></A><H3>
createArgAugmentationsList</H3>
<PRE>
protected void <B>createArgAugmentationsList</B>()</PRE>
<DL>
<DD>A helper method that runs through every nonterminal "pattern" for each
 context in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A>, parses the pattern using <A HREF="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>Treebank.parseNonterminal(danbikel.lisp.Symbol)</CODE></A>, runs through the resulting list of
 augmentations and adds each augmentation symbol to the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><CODE>argAugmentations</CODE></A> list.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createArgNonterminalsSet()"><!-- --></A><H3>
createArgNonterminalsSet</H3>
<PRE>
protected void <B>createArgNonterminalsSet</B>()</PRE>
<DL>
<DD>Sets the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><CODE>argNonterminals</CODE></A> data member to be the static set
 of argument nonterminals.  The default implementation here scans the
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> list, and adds every nonterminal "pattern" for a
 given context to the set.  If the nonterminal to be added is not
 already an argument as determined by <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><CODE>isArgument(danbikel.lisp.Symbol)</CODE></A>, then the
 <A HREF="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><CODE>Treebank.canonicalAugDelimiter()</CODE></A> and <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation"><CODE>defaultArgAugmentation</CODE></A>
 are appended before it is added to the set. This default implementation,
 therefore, does not necessarily return a complete set of all possible arg
 nonterminals, but merely those that are explicitly named in the
 argument-finding contexts. As this method is primarily intended to be
 used by <A HREF="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><CODE>SubcatBag</CODE></A> when setting up its static resources for
 categorizing argument nonterminals, this implementation is sufficient,
 as all nonterminals that are not explicitly named will be thrown into
 the miscellaneous category.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="argNonterminals()"><!-- --></A><H3>
argNonterminals</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.html" title="class or interface in java.util">Set</A> <B>argNonterminals</B>()</PRE>
<DL>
<DD>Returns a static set of possible argument nonterminals.  The default
 implementation here invokes <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#createArgNonterminalsSet()"><CODE>createArgNonterminalsSet()</CODE></A> if
 the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><CODE>argNonterminals</CODE></A> data member has not been initialized
 (that is, if it is <code>null</code>).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#argNonterminals()">argNonterminals</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a static set of possible argument nonterminals</DL>
</DD>
</DL>
<HR>

<A NAME="removeArgAugmentation(danbikel.lisp.Symbol)"><!-- --></A><H3>
removeArgAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>removeArgAugmentation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></B></DD>
<DD>Removes any argument augmentations from the specified nonterminal label.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#removeArgAugmentation(danbikel.lisp.Symbol)">removeArgAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label whose argument augmentations are to be removed
<DT><B>Returns:</B><DD>a new label with no argument augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="removeArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
removeArgAugmentation</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>removeArgAugmentation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                       <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Parses label into the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object and then
 removes all argument augmentations.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label from which to remove argument augmentations<DD><CODE>nonterminal</CODE> - the object to use as temporary storage during
 execution of this method
<DT><B>Returns:</B><DD>the symbol that is the specified label removed of its
 argument augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="removeGapAugmentation(danbikel.lisp.Sexp)"><!-- --></A><H3>
removeGapAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeGapAugmentation</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</PRE>
<DL>
<DD>If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.  Note that
 the presence of gap augmentations is determined by matching for
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><CODE>delimAndGapStr</CODE></A>, which means that symbols consisting solely
 of the gap augmentation itself (<A HREF="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><CODE>gapAugmentation</CODE></A>) will
 be unaffected.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - a symbol or list of symbols from which to remvoe any
 gap augmentations
<DT><B>Returns:</B><DD>a symbol or list of symbols with no gap augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="postProcess(danbikel.lisp.Sexp)"><!-- --></A><H3>
postProcess</H3>
<PRE>
public void <B>postProcess</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></B></DD>
<DD>Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <A HREF="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree to be post-processed</DL>
</DD>
</DL>
<HR>

<A NAME="removeOnlyChildBaseNPs(danbikel.lisp.Sexp)"><!-- --></A><H3>
removeOnlyChildBaseNPs</H3>
<PRE>
protected void <B>removeOnlyChildBaseNPs</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Handle case where an NP dominates a base NP and has no other children
 (the base NP is an "only child" of the dominating NP).  This method
 will effectively remove the base NP node, hooking up all its children
 as the children of the parent NP.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="canonicalizeNonterminals(danbikel.lisp.Sexp)"><!-- --></A><H3>
canonicalizeNonterminals</H3>
<PRE>
protected void <B>canonicalizeNonterminals</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Modifies each nonterminal in the specified tree to be its canonical
 version.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree whose nonterminals are to be converted to their
 canonical versions<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><CODE>Treebank.getCanonical(Symbol)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>[]&nbsp;args)</PRE>
<DL>
<DD>Test driver for this class.  Currently, this method reads in a file
 containing parse trees, invokes the <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><CODE>preProcess(Sexp)</CODE></A> method on
 them, and then outputs the resulting trees to standard out.
 Usage: &lt;filename&gt;, where &lt;filename&gt; contains S-expressions
 representing trees.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readMetadataHook(danbikel.lisp.Symbol, int, danbikel.lisp.SexpList)"><!-- --></A><H3>
readMetadataHook</H3>
<PRE>
protected void <B>readMetadataHook</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;dataType,
                                int&nbsp;metadataLen,
                                <A HREF="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;metadata)</PRE>
<DL>
<DD>A hook for subclasses to have their own custom metadata types.
 The default version here does nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dataType</CODE> - the symbol representing the data type for this
 metadata entry<DD><CODE>metadataLen</CODE> - the length of the list of the specified
 metadata entry<DD><CODE>metadata</CODE> - the list of a metadata entry to be processed
 by a subclass, if the data type is recognized</DL>
</DD>
</DL>
<HR>

<A NAME="readMetadata(danbikel.lisp.SexpTokenizer)"><!-- --></A><H3>
readMetadata</H3>
<PRE>
protected void <B>readMetadata</B>(<A HREF="../../../danbikel/lisp/SexpTokenizer.html" title="class in danbikel.lisp">SexpTokenizer</A>&nbsp;metadataTok)
                     throws <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Reads metadata to fill in <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><CODE>argContexts</CODE></A> and
 <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><CODE>semTagArgStopSet</CODE></A>.  Does no format
 checking on the S-expressions of the metadata resource.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>metadataTok</CODE> - tokenizer for stream of S-expressions containing
 metadata for this class
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="printMetadata()"><!-- --></A><H3>
printMetadata</H3>
<PRE>
public void <B>printMetadata</B>()</PRE>
<DL>
<DD>Debugging method to print the metadata used by this class.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractTraining.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractHeadFinder.HeadFindInstruction.html" title="class in danbikel.parser.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractTraining.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a>
</BODY>
</HTML>
