<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_02) on Tue Sep 27 13:34:36 EDT 2005 -->
<TITLE>
AbstractTreebank (Dan Bikel's Parsing Engine)
</TITLE>

<META NAME="keywords" CONTENT="danbikel.parser.lang.AbstractTreebank class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AbstractTreebank (Dan Bikel's Parsing Engine)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractTreebank.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractTraining.html" title="class in danbikel.parser.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractWordFeatures.html" title="class in danbikel.parser.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractTreebank.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
danbikel.parser.lang</FONT>
<BR>
Class AbstractTreebank</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>danbikel.parser.lang.AbstractTreebank</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A>, <A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../danbikel/parser/english/BrokenTreebank.html" title="class in danbikel.parser.english">BrokenTreebank</A>, <A HREF="../../../danbikel/parser/arabic/Treebank.html" title="class in danbikel.parser.arabic">Treebank</A>, <A HREF="../../../danbikel/parser/chinese/Treebank.html" title="class in danbikel.parser.chinese">Treebank</A>, <A HREF="../../../danbikel/parser/english/Treebank.html" title="class in danbikel.parser.english">Treebank</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>AbstractTreebank</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A><DT>implements <A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A></DL>

<P>
A collection of mostly-abstract methods to be implemented by a
 langauge-specific subclass.  A <code>Treebank</code> implementation
 provides data and methods specific to the structures found in a
 particular Treebank.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#danbikel.parser.lang.AbstractTreebank">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html" title="class or interface in java.util">BitSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimSet">augmentationDelimSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <code>BitSet</code> indexed by character (that is, whose size is
 <code>Character.MAX_VALUE</code>), where for each character <code>c</code>
 of the string returned by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>,
 
 augmentationDelimSet.get(c)
 
 returns <code>true</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#canonicalAugDelimSym">canonicalAugDelimSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Symbol created from the first character of <A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>Treebank.augmentationDelimiters()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#nonterminalExceptionSet">nonterminalExceptionSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A set of nonterminal labels (<code>Symbol</code> objects) that
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A> should use when
 determining the base nonterminal label.  </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#AbstractTreebank()">AbstractTreebank</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No-arg constructor, to be called by all subclasses of this abstract
 class.  </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">addAugmentation</A></B>(<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()">augmentationDelimiters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string whose characters are the set of delimiters for
 complex nonterminal labels.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#baseNPLabel()">baseNPLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol with which <A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> will
 relabel core NPs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#canonicalAugDelimiter()">canonicalAugDelimiter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first character of the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <A HREF="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>Training.identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</A></B>(<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)">containsAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;nonterminal,
                     <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">defaultParseNonterminal</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                        <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getCanonical(danbikel.lisp.Symbol)">getCanonical</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a canonical mapping for the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getCanonical(danbikel.lisp.Symbol, boolean)">getCanonical</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
             boolean&nbsp;stripAugmentations)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getTag(danbikel.lisp.Sexp)">getTag</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the component of the preterminal tree that corresponds to the
 part of speech tag.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">getTraceIndex</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
              <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of a trace for the specified null element preterminal.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isBaseNP(danbikel.lisp.Symbol)">isBaseNP</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified label is for a base NP.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isComma(danbikel.lisp.Symbol)">isComma</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a comma.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isConjunction(danbikel.lisp.Symbol)">isConjunction</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isLeftParen(danbikel.lisp.Symbol)">isLeftParen</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a left
 parenthesis.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isNP(danbikel.lisp.Symbol)">isNP</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is an NP for this language&rsquo;s Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for this
 language&rsquo;s Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPunctuation(danbikel.lisp.Symbol)">isPunctuation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified part of speech tag is one
 for which <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A> would return <code>true</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isRightParen(danbikel.lisp.Symbol)">isRightParen</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a right
 parenthesis.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isSentence(danbikel.lisp.Symbol)">isSentence</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> is the specified nonterminal label represents a
 sentence in this language&rsquo;s Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified preterminal is that of a verb.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isVerbTag(danbikel.lisp.Symbol)">isVerbTag</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isWHNP(danbikel.lisp.Symbol)">isWHNP</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Word</code> object from the specified preterminal
 subtree.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#nonTreebankDelimiter()">nonTreebankDelimiter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#nonTreebankLeftBracket()">nonTreebankLeftBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#nonTreebankRightBracket()">nonTreebankRightBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is
 <tt>true</tt>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#NPLabel()">NPLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol that <A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> should
 add as a parent if a base NP is not dominated by an NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol)">parseNonterminal</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">parseNonterminal</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                 <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>parseNonterminal(Symbol)</CODE></A>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#sentenceLabel()">sentenceLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAllButIndex(danbikel.lisp.Symbol)">stripAllButIndex</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripAllButIndex</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                 <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><CODE>stripAllButIndex(Symbol)</CODE></A>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method
 uses the specified <code>nonterminal</code> object.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAugmentation(danbikel.lisp.Symbol)">stripAugmentation</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripIndex(danbikel.lisp.Symbol)">stripIndex</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>label</code>, but stripped of any index augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripIndex</A></B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
           <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripIndex(danbikel.lisp.Symbol)"><CODE>stripIndex(Symbol)</CODE></A>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method simply passes the
 specified <code>nonterminal</code> object.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#subjectAugmentation()">subjectAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in this language&rsquo;s Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#subjectlessSentenceLabel()">subjectlessSentenceLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol with which <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>
 will relabel sentences when they have no subjects.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="augmentationDelimSet"><!-- --></A><H3>
augmentationDelimSet</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html" title="class or interface in java.util">BitSet</A> <B>augmentationDelimSet</B></PRE>
<DL>
<DD>A <code>BitSet</code> indexed by character (that is, whose size is
 <code>Character.MAX_VALUE</code>), where for each character <code>c</code>
 of the string returned by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>,
 <pre>
 augmentationDelimSet.get(c)
 </pre>
 returns <code>true</code>.  The default constructor of this abstract class
 will appropriately initialize this data member.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="canonicalAugDelimSym"><!-- --></A><H3>
canonicalAugDelimSym</H3>
<PRE>
protected final <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>canonicalAugDelimSym</B></PRE>
<DL>
<DD>A Symbol created from the first character of <A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>Treebank.augmentationDelimiters()</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nonterminalExceptionSet"><!-- --></A><H3>
nonterminalExceptionSet</H3>
<PRE>
protected <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>[] <B>nonterminalExceptionSet</B></PRE>
<DL>
<DD>A set of nonterminal labels (<code>Symbol</code> objects) that
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A> should use when
 determining the base nonterminal label.  If this behavior is desired,
 this array should be assigned in in the constructor of a subclass.
 This hook into the behavior of <code>defaultParseNonterminal</code> is
 primarily intended for the unfortunate case when Treebank designers have
 nonterminal labels that contain the delimiters used for augmenting
 nonterminal labels (as is the case with the English Treebank in the
 form of <tt>-LRB-</tt> and <tt>-RRB-</tt>).
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="AbstractTreebank()"><!-- --></A><H3>
AbstractTreebank</H3>
<PRE>
public <B>AbstractTreebank</B>()</PRE>
<DL>
<DD>No-arg constructor, to be called by all subclasses of this abstract
 class.  This constructor fills in the data member
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimSet"><CODE>augmentationDelimSet</CODE></A> based on the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="isPreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPreterminal</H3>
<PRE>
public abstract boolean <B>isPreterminal</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  Typically, preterminals are
 part-of-speech tags.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTag(danbikel.lisp.Sexp)"><!-- --></A><H3>
getTag</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getTag</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Gets the component of the preterminal tree that corresponds to the
 part of speech tag.  This default implementation returns the symbol
 that is returned by
 <pre>
 preterminal.list().get(0).symbol();
 </pre>
 If this is not appropriate for a particular Treebank, then this method
 should be overridden.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#getTag(danbikel.lisp.Sexp)">getTag</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterminal</CODE> - a tree that is assumed to be a preterminal
<DT><B>Returns:</B><DD>the symbol in <code>preterminal</code> that is a part of speech</DL>
</DD>
</DL>
<HR>

<A NAME="makeWord(danbikel.lisp.Sexp)"><!-- --></A><H3>
makeWord</H3>
<PRE>
public <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>makeWord</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Constructs a <code>Word</code> object from the specified preterminal
 subtree.  This default implementation creates a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object from
 the terminal and preterminal symbols (word and part-of-speech tag
 symbols):
 <pre>
 Words.get(preterminal.list().get(1).symbol(),
	       preterminal.list().get(0).symbol());
 </pre>
 If a particular Treebank requires a different type of word object to be
 constructed, or has a different preterminal tree structure, this method
 should be overridden.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterminal</CODE> - a tree that is assumed to be a preterminal
<DT><B>Returns:</B><DD>the symbol in <code>preterminal</code> that is a part of speech</DL>
</DD>
</DL>
<HR>

<A NAME="constructPreterminal(danbikel.parser.Word)"><!-- --></A><H3>
constructPreterminal</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>constructPreterminal</B>(<A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</PRE>
<DL>
<DD>Converts a <A HREF="../../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.  This default
 implementation creates a tree whose sole nonterminal is the part of speech
 of the specified word object and whose terminal is the word component of
 the specified word object.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word object from which to create a preterminal subtree
<DT><B>Returns:</B><DD>a preterminal subtree constructed from <code>word</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCanonical(danbikel.lisp.Symbol)"><!-- --></A><H3>
getCanonical</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonical</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a canonical mapping for the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.
 This method is intended to be used by implementations of
 <A HREF="../../../danbikel/parser/HeadFinder.html#findHead(danbikel.lisp.Sexp)"><CODE>HeadFinder.findHead(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)">getCanonical</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be canonicalized<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/HeadFinder.html#findHead(danbikel.lisp.Sexp)"><CODE>HeadFinder.findHead(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCanonical(danbikel.lisp.Symbol, boolean)"><!-- --></A><H3>
getCanonical</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonical</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                    boolean&nbsp;stripAugmentations)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></B></DD>
<DD>Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol, boolean)">getCanonical</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be canonicalized<DD><CODE>stripAugmentations</CODE> - indicates whether to strip any augmentations
 from the specified label before attempting to get its canonical form
<DT><B>Returns:</B><DD>the canonical version of the specified label</DL>
</DD>
</DL>
<HR>

<A NAME="isSentence(danbikel.lisp.Symbol)"><!-- --></A><H3>
isSentence</H3>
<PRE>
public abstract boolean <B>isSentence</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> is the specified nonterminal label represents a
 sentence in this language&rsquo;s Treebank.  This method is intended to
 be used by implementations of <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)">isSentence</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentenceLabel()"><!-- --></A><H3>
sentenceLabel</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>sentenceLabel</B>()</PRE>
<DL>
<DD>Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#sentenceLabel()">sentenceLabel</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subjectlessSentenceLabel()"><!-- --></A><H3>
subjectlessSentenceLabel</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>subjectlessSentenceLabel</B>()</PRE>
<DL>
<DD>Returns the symbol with which <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>
 will relabel sentences when they have no subjects.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()">subjectlessSentenceLabel</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subjectAugmentation()"><!-- --></A><H3>
subjectAugmentation</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>subjectAugmentation</B>()</PRE>
<DL>
<DD>Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in this language&rsquo;s Treebank.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#subjectAugmentation()">subjectAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNullElementPreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isNullElementPreterminal</H3>
<PRE>
public abstract boolean <B>isNullElementPreterminal</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for this
 language&rsquo;s Treebank.  This method is intended to be used by implementations
 of <A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)"><!-- --></A><H3>
getTraceIndex</H3>
<PRE>
public int <B>getTraceIndex</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
                         <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Returns the index of a trace for the specified null element preterminal.
 This default implementation assumes trace indicies are marked on trace
 terminals that can be parsed by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>.  If this is not true for a
 particular Treebank, this method should be overridden.  If
 <code>preterm</code> is not a null element preterminal (that is, a
 preterminal for which <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>false</code>), the semantics of this method are undefined.  This
 method is used by the default implementation of <A HREF="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)"><CODE>AbstractTraining.hasGap(Sexp,Sexp,ArrayList)</CODE></A>, which is a helper method
 for the default implementation of <A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>Training.addGapInformation(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">getTraceIndex</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterm</CODE> - the null element preterminal whose trace index is to be
 returned<DD><CODE>nonterminal</CODE> - the object used as the second argument to
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>
<DT><B>Returns:</B><DD>the index of the trace of the terminal contained in
 <code>preterm</code>, or -1 if the null element does not have an index</DL>
</DD>
</DL>
<HR>

<A NAME="isPuncToRaise(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPuncToRaise</H3>
<PRE>
public abstract boolean <B>isPuncToRaise</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  If
 punctuation raising is not desirable for a particular language
 package, this method may be implemented simply to return
 <code>false</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterm</CODE> - the preterminal to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPunctuation(danbikel.lisp.Symbol)"><!-- --></A><H3>
isPunctuation</H3>
<PRE>
public abstract boolean <B>isPunctuation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified part of speech tag is one
 for which <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A> would return <code>true</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)">isPunctuation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tag</CODE> - the part of speech to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPossessivePreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPossessivePreterminal</H3>
<PRE>
public abstract boolean <B>isPossessivePreterminal</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  This method is
 intended to be used by implementations of <A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isNP</H3>
<PRE>
public abstract boolean <B>isNP</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is an NP for this language&rsquo;s Treebank.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)">isNP</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="baseNPLabel()"><!-- --></A><H3>
baseNPLabel</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>baseNPLabel</B>()</PRE>
<DL>
<DD>Returns the symbol with which <A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> will
 relabel core NPs.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#baseNPLabel()">baseNPLabel</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isBaseNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isBaseNP</H3>
<PRE>
public boolean <B>isBaseNP</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns whether the specified label is for a base NP.  The default
 implementation here simply tests for object equality between the
 specified label and the label returned by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#baseNPLabel()"><CODE>baseNPLabel()</CODE></A>.  If
 a particular language package can have various types of base NP labels
 (such as those bearing node augmentations), then this method
 should be overridden.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isBaseNP(danbikel.lisp.Symbol)">isBaseNP</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to test
<DT><B>Returns:</B><DD>whether the specified label is for a base NP.</DL>
</DD>
</DL>
<HR>

<A NAME="isWHNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isWHNP</H3>
<PRE>
public abstract boolean <B>isWHNP</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.  This method
 is used by <A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>Training.addGapInformation(Sexp)</CODE></A>.  If a particular
 language package does not require gap information, then this method may be
 implemented simply to return <code>false</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isWHNP(danbikel.lisp.Symbol)">isWHNP</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>Training.addGapInformation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="NPLabel()"><!-- --></A><H3>
NPLabel</H3>
<PRE>
public abstract <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>NPLabel</B>()</PRE>
<DL>
<DD>Returns the symbol that <A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> should
 add as a parent if a base NP is not dominated by an NP.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#NPLabel()">NPLabel</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isConjunction(danbikel.lisp.Symbol)"><!-- --></A><H3>
isConjunction</H3>
<PRE>
public abstract boolean <B>isConjunction</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isConjunction(danbikel.lisp.Symbol)">isConjunction</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isVerb(danbikel.lisp.Sexp)"><!-- --></A><H3>
isVerb</H3>
<PRE>
public abstract boolean <B>isVerb</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified preterminal is that of a verb.
 This method is used by <A HREF="../../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><CODE>HeadTreeNode</CODE></A> to determine if a particular
 subtree contains a verb, which is in turn used by <A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A> to
 calculate the distance metric, which depends on whether a verb occurs
 in the subtrees of the previous modifiers.  It is the responsibility
 of the caller to insure that <code>preterminal</code> is a
 <code>Sexp</code> object for which <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isPreterminal(danbikel.lisp.Sexp)"><CODE>isPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><CODE>HeadTreeNode</CODE></A>, 
<A HREF="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isVerbTag(danbikel.lisp.Symbol)"><!-- --></A><H3>
isVerbTag</H3>
<PRE>
public abstract boolean <B>isVerbTag</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.  This method should return true for exactly the same
 parts of speech for which <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#isVerb(danbikel.lisp.Sexp)"><CODE>isVerb(Sexp)</CODE></A> returns <code>true</code>,
 and is used to calculate the distance metric while decoding.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isVerbTag(danbikel.lisp.Symbol)">isVerbTag</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/CKYItem.html#containsVerb()"><CODE>CKYItem.containsVerb()</CODE></A>, 
<A HREF="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isComma(danbikel.lisp.Symbol)"><!-- --></A><H3>
isComma</H3>
<PRE>
public abstract boolean <B>isComma</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a comma.  This method
 is used by the <code>Decoder</code> class when performing the comma
 constraint on chart items.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isComma(danbikel.lisp.Symbol)">isComma</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isLeftParen(danbikel.lisp.Symbol)"><!-- --></A><H3>
isLeftParen</H3>
<PRE>
public abstract boolean <B>isLeftParen</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a left
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isLeftParen(danbikel.lisp.Symbol)">isLeftParen</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isRightParen(danbikel.lisp.Symbol)"><!-- --></A><H3>
isRightParen</H3>
<PRE>
public abstract boolean <B>isRightParen</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a right
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isRightParen(danbikel.lisp.Symbol)">isRightParen</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="augmentationDelimiters()"><!-- --></A><H3>
augmentationDelimiters</H3>
<PRE>
public abstract <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A> <B>augmentationDelimiters</B>()</PRE>
<DL>
<DD>Returns a string whose characters are the set of delimiters for
 complex nonterminal labels.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()">augmentationDelimiters</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAugmentation(danbikel.lisp.Symbol)"><CODE>stripAugmentation(Symbol)</CODE></A>, 
<A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="canonicalAugDelimiter()"><!-- --></A><H3>
canonicalAugDelimiter</H3>
<PRE>
public char <B>canonicalAugDelimiter</B>()</PRE>
<DL>
<DD>Returns the first character of the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <A HREF="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>Training.identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()">canonicalAugDelimiter</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankLeftBracket()"><!-- --></A><H3>
nonTreebankLeftBracket</H3>
<PRE>
public char <B>nonTreebankLeftBracket</B>()</PRE>
<DL>
<DD>Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
 The default implementation here returns <tt>'['</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#nonTreebankLeftBracket()">nonTreebankLeftBracket</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a left-bracket character that is not an existing metacharacter
 in the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankRightBracket()"><!-- --></A><H3>
nonTreebankRightBracket</H3>
<PRE>
public char <B>nonTreebankRightBracket</B>()</PRE>
<DL>
<DD>Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is
 <tt>true</tt>. The default implementation here returns <tt>']'</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#nonTreebankRightBracket()">nonTreebankRightBracket</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a right-bracket character that is not an existing metacharacter in
         the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankDelimiter()"><!-- --></A><H3>
nonTreebankDelimiter</H3>
<PRE>
public char <B>nonTreebankDelimiter</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></B></DD>
<DD>Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <A HREF="../../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#nonTreebankDelimiter()">nonTreebankDelimiter</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a delimiter not already in use by the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentation(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAugmentation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)">stripAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the potentially-complex nonterminal label to be stripped
<DT><B>Returns:</B><DD>a version of <code>label</code> with all augmentations removed</DL>
</DD>
</DL>
<HR>

<A NAME="stripIndex(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripIndex</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripIndex</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>label</code>, but stripped of any index augmentation.  This
 method assumes that the index will always be the final augmentation in a
 complex nonterminal label.<br><b>N.B.</b>: This method will create a new
 <code>Nonterminal</code> object, to be filled in by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>stripIndex(Symbol,Nonterminal)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)">stripIndex</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the nonterminal to be stripped of any possible index
<DT><B>Returns:</B><DD>a <code>Symbol</code> that is identical to <code>label</code>,
 except that all characters after and including the final delimiter
 are removed if the final augmentation is composed entirely of digits</DL>
</DD>
</DL>
<HR>

<A NAME="stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
stripIndex</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripIndex</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                         <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripIndex(danbikel.lisp.Symbol)"><CODE>stripIndex(Symbol)</CODE></A>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method simply passes the
 specified <code>nonterminal</code> object.  In a sequential run, this
 method provides maximum efficiency, as only one <code>Nonterminal</code>
 object need be created at the beginning of the run.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripIndex</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stripAllButIndex(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripAllButIndex</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAllButIndex</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.  If
 <code>label</code> had no index to begin with, then this method
 is functionally identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAugmentation(danbikel.lisp.Symbol)"><CODE>stripAugmentation(Symbol)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)">stripAllButIndex</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the nonterminal label to strip of non-index augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
stripAllButIndex</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAllButIndex</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                               <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><CODE>stripAllButIndex(Symbol)</CODE></A>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method
 uses the specified <code>nonterminal</code> object.  In a sequential
 run, this method provides maximum efficiency, as only one
 <code>Nonterminal</code> object need be created at the beginning
 of the run.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripAllButIndex</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="parseNonterminal(danbikel.lisp.Symbol)"><!-- --></A><H3>
parseNonterminal</H3>
<PRE>
public <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A> <B>parseNonterminal</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain
 a list with zero elements; if there is no index, the
 value of index will be -1.  A final requirement of the contract of this
 method is to represent all the delimiters in the list of augmentations;
 this requirement is met, for example, by the helper method <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A>.<br>
 <b>Efficiency note</b>: This method creates and returns a new
 <code>Nonterminal</code> object with every invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)">parseNonterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank
<DT><B>Returns:</B><DD>a <code>Nonterminal</code> object representing any and
 all components of the specified complex nonterminal<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
parseNonterminal</H3>
<PRE>
public abstract <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A> <B>parseNonterminal</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                             <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>parseNonterminal(Symbol)</CODE></A>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.
 This method may be used for efficiency: in a particular, sequential
 training run, only one <code>Nonterminal</code> need be created,
 repeatedly passed in to this method for modification.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">parseNonterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank<DD><CODE>nonterminal</CODE> - the representation of any and all components present
 in <code>label</code></DL>
</DD>
</DL>
<HR>

<A NAME="defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
defaultParseNonterminal</H3>
<PRE>
public void <B>defaultParseNonterminal</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                    <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain a
 list with no elements; if there is no index, the value of index will be
 -1.  Augmentation delimiters are the characters in the string returned by
 <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.<br><b>N.B.</b>: This method assumes that
 the index, if one exists for the specified nonterminal, will always be the
 final augmentation in the label.<br>This method is intended to be used by
 implementations of <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">defaultParseNonterminal</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)"><!-- --></A><H3>
containsAugmentation</H3>
<PRE>
public boolean <B>containsAugmentation</B>(<A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;nonterminal,
                                    <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).
 <p>
 <b>N.B.</b>: This method assumes that the augmentation is preceded
 by the canonical augmentation delimiter.  To search for an augmentation
 preceded by <i>any</i> of the possible augmentaion delimiters (as defined
 by <A HREF="../../../danbikel/parser/lang/AbstractTreebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>), use
 <pre>
 parseNonterminal(nonterminal).augmentations.contains(augmentation)
 </pre>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)">containsAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
addAugmentation</H3>
<PRE>
public void <B>addAugmentation</B>(<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                            <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.
 This method takes care to add the canonical augmentation delimiter
 before adding the augmentation itself, and also takes care to add
 these two elements before a final delimiter between the main augmentations
 and the index, if one exists.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">addAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminal</CODE> - the nonterminal to which to add an augmentation<DD><CODE>augmentation</CODE> - the augmentation to add to <code>nonterminal</code>'s
 augmentation list</DL>
</DD>
</DL>
<HR>

<A NAME="removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
removeAugmentation</H3>
<PRE>
public boolean <B>removeAugmentation</B>(<A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                                  <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.  If the specified augmentation is <i>not</i> preceded by
 an augmentation delimiter, meaning it is the base label itself, then it
 is not removed.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminal</CODE> - the nonterminal from which to remove an augmentation<DD><CODE>augmentation</CODE> - the augmentation to remove from
 <code>nonterminal</code>
<DT><B>Returns:</B><DD><code>true</code> if <code>augmentation</code> and
 a preceding augmentation delimiter was removed from
 <code>nonterminal</code>'s augmentation list, or <code>false</code>
 otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
removeAugmentation</H3>
<PRE>
public <A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeAugmentation</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                               <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                               <A HREF="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></B></DD>
<DD>Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  If the specified S-expression is a list, then each element will
 be destructively replaced with the return value of this method; otherwise,
 if the specified S-epxression is a symbol, its augmentation is removed and
 the new symbol is returned.
 <p/>
 <b>N.B.</b>: While the description of the behavior of this method on lists
 is recursive, a concrete implementation need not use a recursive
 algorithm.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - the S-expression containing symbols whose augmentations
                     are to be removed<DD><CODE>nonterminal</CODE> - an object used for temporary storage during the
                     invocation of this method<DD><CODE>augmentation</CODE> - the augmentation to be removed from all symbols in the
                     specified S-expression
<DT><B>Returns:</B><DD>the specified S-expression, but with all symbols changed so that
         none has the specified augmentation</DL>
</DD>
</DL>
<HR>

<A NAME="isAugDelim(danbikel.lisp.Sexp)"><!-- --></A><H3>
isAugDelim</H3>
<PRE>
public final boolean <B>isAugDelim</B>(<A HREF="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></B></DD>
<DD>Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</A></CODE> in interface <CODE><A HREF="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - the S-expression to be tested
<DT><B>Returns:</B><DD>whether the specified S-expression is a symbol that is an
 augmentation delimiter.<DT><B>See Also:</B><DD><A HREF="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>Treebank.augmentationDelimiters()</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractTreebank.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractTraining.html" title="class in danbikel.parser.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../danbikel/parser/lang/AbstractWordFeatures.html" title="class in danbikel.parser.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractTreebank.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a>
</BODY>
</HTML>
