<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_02) on Tue Sep 27 13:34:42 EDT 2005 -->
<TITLE>
Treebank (Dan Bikel's Parsing Engine)
</TITLE>

<META NAME="keywords" CONTENT="danbikel.parser.Treebank interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Treebank (Dan Bikel's Parsing Engine)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Treebank.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Treebank.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
danbikel.parser</FONT>
<BR>
Interface Treebank</H2>
<DL>
<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang">AbstractTreebank</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>Treebank</B></DL>

<P>
A <code>Treebank</code> implementation provides data and methods specific
 to the structures found in a particular Treebank.
 <p>
 A language package must provide an implementation of this interface.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">addAugmentation</A></B>(<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()">augmentationDelimiters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string whose characters are the set of delimiters for complex
 nonterminal labels.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#baseNPLabel()">baseNPLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol with which <A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> will
 relabel core NPs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#canonicalAugDelimiter()">canonicalAugDelimiter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first character of the string returned by
 <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>Training.identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</A></B>(<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)">containsAugmentation</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;nonterminal,
                     <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">defaultParseNonterminal</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                        <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)">getCanonical</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol, boolean)">getCanonical</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
             boolean&nbsp;stripAugmentations)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#getTag(danbikel.lisp.Sexp)">getTag</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the component of the preterminal tree that corresponds to the
 part of speech tag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">getTraceIndex</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
              <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of a trace for the specified null element preterminal.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isBaseNP(danbikel.lisp.Symbol)">isBaseNP</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified label is for a base NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isComma(danbikel.lisp.Symbol)">isComma</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a comma.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isConjunction(danbikel.lisp.Symbol)">isConjunction</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isLeftParen(danbikel.lisp.Symbol)">isLeftParen</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a left
 parenthesis.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)">isNP</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is an NP for the current language's Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for the current
 language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)">isPunctuation</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified part of speech tag is one
 for which <A HREF="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A> would return <code>true</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isRightParen(danbikel.lisp.Symbol)">isRightParen</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified word is a right
 parenthesis.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)">isSentence</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> is the specified nonterminal label represents a
 sentence in the current language's Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified preterminal is that of a verb.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isVerbTag(danbikel.lisp.Symbol)">isVerbTag</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#isWHNP(danbikel.lisp.Symbol)">isWHNP</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Word</code> object from the specified preterminal
 subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#nonTreebankDelimiter()">nonTreebankDelimiter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#nonTreebankLeftBracket()">nonTreebankLeftBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#nonTreebankRightBracket()">nonTreebankRightBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is
 <tt>true</tt>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#NPLabel()">NPLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol that <A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> should
 add as a parent if a base NP is not dominated by an NP.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)">parseNonterminal</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">parseNonterminal</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                 <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>parseNonterminal(Symbol)</CODE></A>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">removeAugmentation</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                   <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                   <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#sentenceLabel()">sentenceLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)">stripAllButIndex</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripAllButIndex</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                 <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><CODE>stripAllButIndex(Symbol)</CODE></A>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method
 uses the specified <code>nonterminal</code> object.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)">stripAugmentation</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)">stripIndex</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>label</code>, but stripped of any index augmentation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">stripIndex</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
           <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Identical to <A HREF="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)"><CODE>stripIndex(Symbol)</CODE></A>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method simply passes the
 specified <code>nonterminal</code> object.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#subjectAugmentation()">subjectAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in the current language's Treebank.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()">subjectlessSentenceLabel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol with which <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>
 will relabel sentences when they have no subjects.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="isPreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPreterminal</H3>
<PRE>
public boolean <B>isPreterminal</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  Typically, preterminals are
 part-of-speech tags.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTag(danbikel.lisp.Sexp)"><!-- --></A><H3>
getTag</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getTag</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Gets the component of the preterminal tree that corresponds to the
 part of speech tag.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterminal</CODE> - a tree that is assumed to be a preterminal
<DT><B>Returns:</B><DD>the symbol in <code>preterminal</code> that is a part of speech</DL>
</DD>
</DL>
<HR>

<A NAME="makeWord(danbikel.lisp.Sexp)"><!-- --></A><H3>
makeWord</H3>
<PRE>
public <A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>makeWord</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Constructs a <code>Word</code> object from the specified preterminal
 subtree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterminal</CODE> - a tree that is assumed to be a preterminal
<DT><B>Returns:</B><DD>the symbol in <code>preterminal</code> that is a part of speech</DL>
</DD>
</DL>
<HR>

<A NAME="constructPreterminal(danbikel.parser.Word)"><!-- --></A><H3>
constructPreterminal</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>constructPreterminal</B>(<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A>&nbsp;word)</PRE>
<DL>
<DD>Converts a <A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser"><CODE>Word</CODE></A> object into a preterminal subtree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word object from which to create a preterminal subtree
<DT><B>Returns:</B><DD>a preterminal subtree constructed from <code>word</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCanonical(danbikel.lisp.Symbol)"><!-- --></A><H3>
getCanonical</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonical</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be canonicalized</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonical(danbikel.lisp.Symbol, boolean)"><!-- --></A><H3>
getCanonical</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonical</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                           boolean&nbsp;stripAugmentations)</PRE>
<DL>
<DD>Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to be canonicalized<DD><CODE>stripAugmentations</CODE> - indicates whether to strip any augmentations
 from the specified label before attempting to get its canonical form
<DT><B>Returns:</B><DD>the canonical version of the specified label</DL>
</DD>
</DL>
<HR>

<A NAME="isSentence(danbikel.lisp.Symbol)"><!-- --></A><H3>
isSentence</H3>
<PRE>
public boolean <B>isSentence</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> is the specified nonterminal label represents a
 sentence in the current language's Treebank.  This method is intended to
 be used by implementations of <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentenceLabel()"><!-- --></A><H3>
sentenceLabel</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>sentenceLabel</B>()</PRE>
<DL>
<DD>Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subjectlessSentenceLabel()"><!-- --></A><H3>
subjectlessSentenceLabel</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>subjectlessSentenceLabel</B>()</PRE>
<DL>
<DD>Returns the symbol with which <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>
 will relabel sentences when they have no subjects.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subjectAugmentation()"><!-- --></A><H3>
subjectAugmentation</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>subjectAugmentation</B>()</PRE>
<DL>
<DD>Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in the current language's Treebank.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNullElementPreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isNullElementPreterminal</H3>
<PRE>
public boolean <B>isNullElementPreterminal</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for the current
 language's Treebank.  This method is intended to be used by implementations
 of <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>Training.relabelSubjectlessSentences(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)"><!-- --></A><H3>
getTraceIndex</H3>
<PRE>
public int <B>getTraceIndex</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm,
                         <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Returns the index of a trace for the specified null element preterminal.
 If <code>preterm</code> is not a null element preterminal (that is, a
 preterminal for which <A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>false</code>), the semantics of this method are undefined.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterm</CODE> - the null element preterminal whose trace index is to be
 returned<DD><CODE>nonterminal</CODE> - the object used as the second argument to
 <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>
<DT><B>Returns:</B><DD>the index of the trace of the terminal contained in
 <code>preterm</code>, or -1 if the null element does not have an index</DL>
</DD>
</DL>
<HR>

<A NAME="isPuncToRaise(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPuncToRaise</H3>
<PRE>
public boolean <B>isPuncToRaise</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterm)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <A HREF="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A>.  If
 punctuation raising is not desirable for a particular language
 package, this method may be implemented simply to return
 <code>false</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preterm</CODE> - the preterminal to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>Training.raisePunctuation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPunctuation(danbikel.lisp.Symbol)"><!-- --></A><H3>
isPunctuation</H3>
<PRE>
public boolean <B>isPunctuation</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified part of speech tag is one
 for which <A HREF="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A> would return <code>true</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tag</CODE> - the part of speech to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>isPuncToRaise(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPossessivePreterminal(danbikel.lisp.Sexp)"><!-- --></A><H3>
isPossessivePreterminal</H3>
<PRE>
public boolean <B>isPossessivePreterminal</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  This method is
 intended to be used by implementations of <A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isNP</H3>
<PRE>
public boolean <B>isNP</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is an NP for the current language's Treebank.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="baseNPLabel()"><!-- --></A><H3>
baseNPLabel</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>baseNPLabel</B>()</PRE>
<DL>
<DD>Returns the symbol with which <A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> will
 relabel core NPs.<br>
 <b>N.B.</b>: This method should <i><b>not</b></i> be used as a predicate
 for testing whether a particular nonterminal label is that of a base NP.
 For that purpose, use <A HREF="../../danbikel/parser/Treebank.html#isBaseNP(danbikel.lisp.Symbol)"><CODE>isBaseNP(Symbol)</CODE></A>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isBaseNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isBaseNP</H3>
<PRE>
public boolean <B>isBaseNP</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns whether the specified label is for a base NP.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label to test
<DT><B>Returns:</B><DD>whether the specified label is for a base NP.</DL>
</DD>
</DL>
<HR>

<A NAME="isWHNP(danbikel.lisp.Symbol)"><!-- --></A><H3>
isWHNP</H3>
<PRE>
public boolean <B>isWHNP</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.  This method
 is used by <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>Training.addGapInformation(Sexp)</CODE></A>.  If a particular
 language package does not require gap information, then this method may be
 implemented simply to return <code>false</code>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>Training.addGapInformation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="NPLabel()"><!-- --></A><H3>
NPLabel</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>NPLabel</B>()</PRE>
<DL>
<DD>Returns the symbol that <A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A> should
 add as a parent if a base NP is not dominated by an NP.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><CODE>Training.addBaseNPs(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isConjunction(danbikel.lisp.Symbol)"><!-- --></A><H3>
isConjunction</H3>
<PRE>
public boolean <B>isConjunction</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isVerb(danbikel.lisp.Sexp)"><!-- --></A><H3>
isVerb</H3>
<PRE>
public boolean <B>isVerb</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;preterminal)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified preterminal is that of a verb.
 This method is used by <A HREF="../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><CODE>HeadTreeNode</CODE></A> to determine if a particular
 subtree contains a verb, which is in turn used by <A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A> to
 calculate the distance metric, which depends on whether a verb occurs
 in the subtrees of the previous modifiers.  It is the responsibility
 of the caller to insure that <code>preterminal</code> is a
 <code>Sexp</code> object for which <A HREF="../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)"><CODE>isPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><CODE>HeadTreeNode</CODE></A>, 
<A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isVerbTag(danbikel.lisp.Symbol)"><!-- --></A><H3>
isVerbTag</H3>
<PRE>
public boolean <B>isVerbTag</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.  This method should return true for exactly the same
 parts of speech for which <A HREF="../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)"><CODE>isVerb(Sexp)</CODE></A> returns <code>true</code>,
 and is used to calculate the distance metric while decoding.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/CKYItem.html#containsVerb()"><CODE>CKYItem.containsVerb()</CODE></A>, 
<A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isComma(danbikel.lisp.Symbol)"><!-- --></A><H3>
isComma</H3>
<PRE>
public boolean <B>isComma</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a comma.  This method
 is used by the <code>Decoder</code> class when performing the comma
 constraint on chart items.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isLeftParen(danbikel.lisp.Symbol)"><!-- --></A><H3>
isLeftParen</H3>
<PRE>
public boolean <B>isLeftParen</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a left
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isRightParen(danbikel.lisp.Symbol)"><!-- --></A><H3>
isRightParen</H3>
<PRE>
public boolean <B>isRightParen</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word)</PRE>
<DL>
<DD>Returns <code>true</code> if the specified word is a right
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - the word to test<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><CODE>Settings.decoderUseCommaConstraint</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="augmentationDelimiters()"><!-- --></A><H3>
augmentationDelimiters</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A> <B>augmentationDelimiters</B>()</PRE>
<DL>
<DD>Returns a string whose characters are the set of delimiters for complex
 nonterminal labels.
 <p/>
 <b>Implementation note</b>: The return value of this method should be used
 only to implement the other methods of interface.  Construction of and
 predicates over complex nonterminals should be handled by the other methods
 specified in this interface that either take a <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> as an
 argument or return a <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)"><CODE>isAugDelim(Sexp)</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)"><CODE>stripAugmentation(Symbol)</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="canonicalAugDelimiter()"><!-- --></A><H3>
canonicalAugDelimiter</H3>
<PRE>
public char <B>canonicalAugDelimiter</B>()</PRE>
<DL>
<DD>Returns the first character of the string returned by
 <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>Training.identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankLeftBracket()"><!-- --></A><H3>
nonTreebankLeftBracket</H3>
<PRE>
public char <B>nonTreebankLeftBracket</B>()</PRE>
<DL>
<DD>Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
 For most treebanks, <tt>'['</tt> is a good default.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a left-bracket character that is not an existing metacharacter
 in the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankRightBracket()"><!-- --></A><H3>
nonTreebankRightBracket</H3>
<PRE>
public char <B>nonTreebankRightBracket</B>()</PRE>
<DL>
<DD>Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is
 <tt>true</tt>. For most treebanks, <tt>']'</tt> is a good default.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a right-bracket character that is not an existing metacharacter in
         the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="nonTreebankDelimiter()"><!-- --></A><H3>
nonTreebankDelimiter</H3>
<PRE>
public char <B>nonTreebankDelimiter</B>()</PRE>
<DL>
<DD>Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <A HREF="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><CODE>Settings.decoderOutputHeadLexicalizedLabels</CODE></A> is <tt>true</tt>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a delimiter not already in use by the current treebank</DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentation(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripAugmentation</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAugmentation</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the potentially-complex nonterminal label to be stripped
<DT><B>Returns:</B><DD>a version of <code>label</code> with all augmentations removed</DL>
</DD>
</DL>
<HR>

<A NAME="stripIndex(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripIndex</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripIndex</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>label</code>, but stripped of any index augmentation.  This
 method assumes that the index will always be the final augmentation in a
 complex nonterminal label.<br><b>N.B.</b>: This method will create a new
 <code>Nonterminal</code> object, to be filled in by <A HREF="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>stripIndex(Symbol,Nonterminal)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the nonterminal to be stripped of any possible index
<DT><B>Returns:</B><DD>a <code>Symbol</code> that is identical to <code>label</code>,
 except that all characters after and including the final delimiter
 are removed if the final augmentation is composed entirely of digits</DL>
</DD>
</DL>
<HR>

<A NAME="stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
stripIndex</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripIndex</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                         <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)"><CODE>stripIndex(Symbol)</CODE></A>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method simply passes the
 specified <code>nonterminal</code> object.  In a sequential run, this
 method provides maximum efficiency, as only one <code>Nonterminal</code>
 object need be created at the beginning of the run.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stripAllButIndex(danbikel.lisp.Symbol)"><!-- --></A><H3>
stripAllButIndex</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAllButIndex</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.  If
 <code>label</code> had no index to begin with, then this method
 is functionally identical to <A HREF="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)"><CODE>stripAugmentation(Symbol)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the nonterminal label to strip of non-index augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
stripAllButIndex</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stripAllButIndex</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                               <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><CODE>stripAllButIndex(Symbol)</CODE></A>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>, this method
 uses the specified <code>nonterminal</code> object.  In a sequential
 run, this method provides maximum efficiency, as only one
 <code>Nonterminal</code> object need be created at the beginning
 of the run.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="parseNonterminal(danbikel.lisp.Symbol)"><!-- --></A><H3>
parseNonterminal</H3>
<PRE>
public <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A> <B>parseNonterminal</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain
 a list with zero elements; if there is no index, the
 value of index will be -1.  A final requirement of the contract of this
 method is to represent all the delimiters in the list of augmentations;
 this requirement is met, for example, by the helper method <A HREF="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>defaultParseNonterminal(Symbol,Nonterminal)</CODE></A>.<br>
 <b>Efficiency note</b>: This method creates and returns a new
 <code>Nonterminal</code> object with every invocation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank
<DT><B>Returns:</B><DD>a <code>Nonterminal</code> object representing any and
 all components of the specified complex nonterminal<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
parseNonterminal</H3>
<PRE>
public <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A> <B>parseNonterminal</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                    <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Identical to <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><CODE>parseNonterminal(Symbol)</CODE></A>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.
 This method may be used for efficiency: in a particular, sequential
 training run, only one <code>Nonterminal</code> need be created,
 repeatedly passed in to this method for modification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank<DD><CODE>nonterminal</CODE> - the representation of any and all components present
 in <code>label</code></DL>
</DD>
</DL>
<HR>

<A NAME="defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><!-- --></A><H3>
defaultParseNonterminal</H3>
<PRE>
public void <B>defaultParseNonterminal</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label,
                                    <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal)</PRE>
<DL>
<DD>Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain a
 list with no elements; if there is no index, the value of index will be
 -1.  Augmentation delimiters are the characters in the string returned by
 <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>.<br><b>N.B.</b>: This method assumes that
 the index, if one exists for the specified nonterminal, will always be the
 final augmentation in the label.<br>This method is intended to be used by
 implementations of <A HREF="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)"><CODE>parseNonterminal(Symbol,Nonterminal)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - a (possibly complex) nonterminal label from a Treebank<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)"><!-- --></A><H3>
containsAugmentation</H3>
<PRE>
public boolean <B>containsAugmentation</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;nonterminal,
                                    <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).
 <p>
 <b>N.B.</b>: This method assumes that the augmentation is preceded
 by the canonical augmentation delimiter.  To search for an augmentation
 preceded by <i>any</i> of the possible augmentaion delimiters (as defined
 by <A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A>), use
 <pre>
 parseNonterminal(nonterminal).augmentations.contains(augmentation)
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
addAugmentation</H3>
<PRE>
public void <B>addAugmentation</B>(<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                            <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.
 This method takes care to add the canonical augmentation delimiter
 before adding the augmentation itself, and also takes care to add
 these two elements before a final delimiter between the main augmentations
 and the index, if one exists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminal</CODE> - the nonterminal to which to add an augmentation<DD><CODE>augmentation</CODE> - the augmentation to add to <code>nonterminal</code>'s
 augmentation list</DL>
</DD>
</DL>
<HR>

<A NAME="removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
removeAugmentation</H3>
<PRE>
public boolean <B>removeAugmentation</B>(<A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                                  <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.  If the specified augmentation is <i>not</i> preceded by an
 augmentation delimiter, meaning it is the base label itself, then it is not
 removed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminal</CODE> - the nonterminal from which to remove an augmentation<DD><CODE>augmentation</CODE> - the augmentation to remove from <code>nonterminal</code>
<DT><B>Returns:</B><DD><code>true</code> if <code>augmentation</code> and a preceding
         augmentation delimiter was removed from <code>nonterminal</code>'s
         augmentation list, or <code>false</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)"><!-- --></A><H3>
removeAugmentation</H3>
<PRE>
public <A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeAugmentation</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp,
                               <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</A>&nbsp;nonterminal,
                               <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;augmentation)</PRE>
<DL>
<DD>Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <A HREF="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><CODE>Nonterminal</CODE></A> object for temporary
 storage.  If the specified S-expression is a list, then each element will
 be destructively replaced with the return value of this method; otherwise,
 if the specified S-epxression is a symbol, its augmentation is removed and
 the new symbol is returned.
 <p/>
 <b>N.B.</b>: While the description of the behavior of this method on lists
 is recursive, a concrete implementation need not use a recursive
 algorithm.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - the S-expression containing symbols whose augmentations
                     are to be removed<DD><CODE>nonterminal</CODE> - an object used for temporary storage during the
                     invocation of this method<DD><CODE>augmentation</CODE> - the augmentation to be removed from all symbols in the
                     specified S-expression
<DT><B>Returns:</B><DD>the specified S-expression, but with all symbols changed so that
         none has the specified augmentation</DL>
</DD>
</DL>
<HR>

<A NAME="isAugDelim(danbikel.lisp.Sexp)"><!-- --></A><H3>
isAugDelim</H3>
<PRE>
public boolean <B>isAugDelim</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</PRE>
<DL>
<DD>Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - the S-expression to be tested
<DT><B>Returns:</B><DD>whether the specified S-expression is a symbol that is an
 augmentation delimiter.<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><CODE>augmentationDelimiters()</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Treebank.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Treebank.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a>
</BODY>
</HTML>
